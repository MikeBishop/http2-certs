<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head profile="http://www.w3.org/2006/03/hcard http://dublincore.org/documents/2008/08/04/dc-html/">
  <meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />

  <title>Secondary Certificate Authentication in HTTP/2</title>

  
<style type="text/css">/*<![CDATA[*/
@viewport {
  zoom: 1.0;
  width: extend-to-zoom;
}
@-ms-viewport {
  width: extend-to-zoom;
  zoom: 1.0;
}

@media screen and (min-width: 1024px) {
  ul.toc, #rfc\.toc {
    position: fixed;
    bottom: 0;
    right: 0;
    right: calc(50vw - 525px);
    width: 300px;
    z-index: 1;
  }
  #rfc\.toc {
    top: 15px;
  }
  ul.toc {
    top: 80px;
    overflow: auto;
  }

  body {
    padding-right: 350px;
  }
}

body {
  font: 15px "Helvetica Neue",Helvetica,Arial,sans-serif;
  color: #333;
  font-size-adjust: 0.5;
  line-height: 130%;
  margin: 25px auto;
  max-width: 724px;
}

.title, .filename, h1, h2, h3, h4 {
  font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
  font-size-adjust: 0.5;
  font-weight: 500;
  color: #333;
  line-height: 100%;
  margin: 0.8em 0 0.3em;
}
.title { font-size: 36px; }
h1 { font-size: 30px; }
h2 { font-size: 24px; }
h3, h4 { font-size: 18px; }
h1 a[href], h2 a[href], h3 a[href], h4 a[href] {
  color: #333;
}

ul.toc li {
  list-style: none;
  text-indent: -2.5em;
  padding-left: 2.5em;
  padding-bottom: 5px;
  margin: 0;
}
ul.toc ul {
  margin: 0;
}
/* xml2rfc nests ul directly inside ul which messes with the style badly */
ul.toc, ul.toc>ul, ul.toc ul>ul {
  margin: 0 0 0 1.5em;
}

table {
  margin-left: 0em;
  border-collapse: collapse;
}
th {
  text-align: left;
  border-bottom: 2px solid #ddd;
}
td {
  border-top: 1px solid #ddd;
  vertical-align: top;
}
tr:nth-child(2n+1) > td,
tr:nth-child(2n+1) > th {
  background-color: #f9f9f9;
}
td.reference {
  max-width: 200px;
  border-top: none;
  padding-right: 1em;
}
.right {
  text-align: right;
}


table.header {
  width: 100%;
}
table.header td {
  border: none;
  background-color: transparent;
  color: black;
}
.filename {
  color: rgb(119, 119, 119);
  font-size: 23px;
  font-weight: normal;
  height: auto;
  line-height: 100%;
}
#rfc\.abstract+p {
  font-size: 20px;
  font-weight: 300;
  line-height: 130%;
}

samp, tt, code, pre {
  font: 11pt consolas, monospace;
  font-size-adjust: none;
}
pre {
  background-color: #eee;
  border: 1px solid #ddd;
  overflow-x: auto;
  padding: 5px;
  margin: 5px;
}
.figure {
  font-style: italic;
  margin: 0 1.5em;
}

address {
  margin: 10px 0 0;
}
.vcard {
  font-style: normal;
}
.vcardline {
  display: block;
}
.vcardline .fn {
  font-weight: bold;
}
.vcardline .hidden {
  display: none;
}

dl {
  margin-left: 1em;
}
dl.dl-horizontal: {
  margin-left: 0;
}
dl > dt {
  float: left;
  margin-right: 1em;
}
dl.nohang > dt {
  float: none;
}
dl > dd {
  margin-bottom: .5em;
}
dl.compact > dd {
  margin-bottom: 0em;
}
dl > dd > dl {
  margin-top: 0.5em;
  margin-bottom: 0em;
}
ul.empty {
  list-style-type: none;
}
ul.empty li {
  margin-top: .5em;
}

hr {
  border: 0;
  border-top: 1px solid #eee;
}

a {
  text-decoration: none;
}
a[href] {
  color: #2a6496;
}
a[href]:hover {
  background-color: #eee;
}

ol, ul, li, p {
  padding: 0;
  margin: 0.5em 0 0.5em 2em;
}
li, p {
  margin-left: 0;
}
address {
  font-style: normal;
}

.github-fork-ribbon-wrapper {
  display: none;
}
@media screen and (min-width: 800px) {
  /* "Fork me on GitHub" CSS ribbon based on
   * https://github.com/simonwhitaker/github-fork-ribbon-css
   */
  .github-fork-ribbon {
    position: absolute;
    padding: 2px 0;
    background-color: #a00;
    background-image: linear-gradient(to bottom, rgba(0, 0, 0, 0), rgba(0, 0, 0, 0.15));
    box-shadow: 0 2px 3px 0 rgba(0, 0, 0, 0.5);
    font: 700 12px "Helvetica Neue", Helvetica, Arial, sans-serif;

    pointer-events: auto;

    top: 38px;
    right: -45px;

    transform: rotate(45deg);
  }

  .github-fork-ribbon a[href],
  .github-fork-ribbon a[href]:hover {
    color: #fff;
    background-color: transparent;
    text-decoration: none;
    text-shadow: 0 -1px rgba(0, 0, 0, 0.5);
    text-align: center;

    width: 190px;
    line-height: 18px;

    display: inline-block;
    padding: 2px 0;

    border: 1.5px dotted #fff;
    border-color: rgba(255, 255, 255, 0.6);
  }

  .github-fork-ribbon-wrapper {
    display: block;
    width: 130px;
    height: 130px;
    position: absolute;
    overflow: hidden;
    top: 0; right: 0;
    z-index: 2;
    pointer-events: none;
  }
}
@media screen and (min-width: 1000px) {
  .github-fork-ribbon-wrapper {
    position: fixed;
  }
  /*]]>*/</style>


  <link href="#rfc.toc" rel="Contents">
<link href="#rfc.section.1" rel="Chapter" title="1 Introduction">
<link href="#rfc.section.1.1" rel="Chapter" title="1.1 Server Certificate Authentication">
<link href="#rfc.section.1.2" rel="Chapter" title="1.2 Client Certificate Authentication">
<link href="#rfc.section.1.2.1" rel="Chapter" title="1.2.1 HTTP/1.1 using TLS 1.2 and previous">
<link href="#rfc.section.1.2.2" rel="Chapter" title="1.2.2 HTTP/1.1 using TLS 1.3">
<link href="#rfc.section.1.2.3" rel="Chapter" title="1.2.3 HTTP/2">
<link href="#rfc.section.1.3" rel="Chapter" title="1.3 HTTP-Layer Certificate Authentication">
<link href="#rfc.section.1.4" rel="Chapter" title="1.4 Terminology">
<link href="#rfc.section.2" rel="Chapter" title="2 Discovering Additional Certificates at the HTTP/2 Layer">
<link href="#rfc.section.2.1" rel="Chapter" title="2.1 Indicating support for HTTP-layer certificate authentication">
<link href="#rfc.section.2.2" rel="Chapter" title="2.2 Making certificates or requests available">
<link href="#rfc.section.2.3" rel="Chapter" title="2.3 Requiring certificate authentication">
<link href="#rfc.section.3" rel="Chapter" title="3 Certificates Frames for HTTP/2">
<link href="#rfc.section.3.1" rel="Chapter" title="3.1 The CERTIFICATE_NEEDED frame">
<link href="#rfc.section.3.2" rel="Chapter" title="3.2 The USE_CERTIFICATE Frame">
<link href="#rfc.section.3.3" rel="Chapter" title="3.3 The CERTIFICATE_REQUEST Frame">
<link href="#rfc.section.3.4" rel="Chapter" title="3.4 The CERTIFICATE Frame">
<link href="#rfc.section.3.4.1" rel="Chapter" title="3.4.1 Exported Authenticator Characteristics">
<link href="#rfc.section.4" rel="Chapter" title="4 Indicating failures during HTTP-Layer Certificate Authentication">
<link href="#rfc.section.5" rel="Chapter" title="5 Security Considerations">
<link href="#rfc.section.5.1" rel="Chapter" title="5.1 Impersonation">
<link href="#rfc.section.5.2" rel="Chapter" title="5.2 Fingerprinting">
<link href="#rfc.section.5.3" rel="Chapter" title="5.3 Denial of Service">
<link href="#rfc.section.5.4" rel="Chapter" title="5.4 Confusion About State">
<link href="#rfc.section.6" rel="Chapter" title="6 IANA Considerations">
<link href="#rfc.section.6.1" rel="Chapter" title="6.1 HTTP/2 SETTINGS_HTTP_CERT_AUTH Setting">
<link href="#rfc.section.6.2" rel="Chapter" title="6.2 New HTTP/2 Frames">
<link href="#rfc.section.6.3" rel="Chapter" title="6.3 New HTTP/2 Error Codes">
<link href="#rfc.section.7" rel="Chapter" title="7 Acknowledgements">
<link href="#rfc.references" rel="Chapter" title="8 References">
<link href="#rfc.references.1" rel="Chapter" title="8.1 Normative References">
<link href="#rfc.references.2" rel="Chapter" title="8.2 Informative References">
<link href="#rfc.authors" rel="Chapter">


  <meta name="generator" content="xml2rfc version 2.8.2 - https://tools.ietf.org/tools/xml2rfc" />
  <link rel="schema.dct" href="http://purl.org/dc/terms/" />

  <meta name="dct.creator" content="Bishop, M., Sullivan, N., and M. Thomson" />
  <meta name="dct.identifier" content="urn:ietf:id:draft-bishop-httpbis-http2-additional-certs-latest" />
  <meta name="dct.issued" scheme="ISO8601" content="2017-10-30" />
  <meta name="dct.abstract" content="TLS provides fundamental mutual authentication services for HTTP, supporting up to one server certificate and up to one client certificate associated to the session to prove client and server identities as necessary. This draft provides mechanisms for providing additional such certificates at the HTTP layer when these constraints are not sufficient." />
  <meta name="description" content="TLS provides fundamental mutual authentication services for HTTP, supporting up to one server certificate and up to one client certificate associated to the session to prove client and server identities as necessary. This draft provides mechanisms for providing additional such certificates at the HTTP layer when these constraints are not sufficient." />

</head>

<body>

  <table class="header">
    <tbody>
    
    	<tr>
<td class="left">HTTP</td>
<td class="right">M. Bishop</td>
</tr>
<tr>
<td class="left">Internet-Draft</td>
<td class="right"></td>
</tr>
<tr>
<td class="left">Intended status: Standards Track</td>
<td class="right">N. Sullivan</td>
</tr>
<tr>
<td class="left">Expires: May 3, 2018</td>
<td class="right">Cloudflare</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">M. Thomson</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">Mozilla</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">October 30, 2017</td>
</tr>

    	
    </tbody>
  </table>

  <p class="title">Secondary Certificate Authentication in HTTP/2<br />
  <span class="filename">draft-bishop-httpbis-http2-additional-certs-latest</span></p>
  
  <h1 id="rfc.abstract"><a href="#rfc.abstract">Abstract</a></h1>
<p>TLS provides fundamental mutual authentication services for HTTP, supporting up to one server certificate and up to one client certificate associated to the session to prove client and server identities as necessary. This draft provides mechanisms for providing additional such certificates at the HTTP layer when these constraints are not sufficient.</p>
<p>Many HTTP servers host content from several origins. HTTP/2 <a href="#RFC7540" class="xref">[RFC7540]</a> permits clients to reuse an existing HTTP connection to a server provided that the secondary origin is also in the certificate provided during the TLS <a href="#I-D.ietf-tls-tls13" class="xref">[I-D.ietf-tls-tls13]</a> handshake.</p>
<p>In many cases, servers will wish to maintain separate certificates for different origins but still desire the benefits of a shared HTTP connection. Similarly, servers may require clients to present authentication, but have different requirements based on the content the client is attempting to access.</p>
<p>This document describes how TLS exported authenticators <a href="#I-D.ietf-tls-exported-authenticator" class="xref">[I-D.ietf-tls-exported-authenticator]</a> can be used to provide proof of ownership of additional certificates to the HTTP layer to support both scenarios.</p>
<h1 id="rfc.status"><a href="#rfc.status">Status of This Memo</a></h1>
<p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p>
<p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF).  Note that other groups may also distribute working documents as Internet-Drafts.  The list of current Internet-Drafts is at https://datatracker.ietf.org/drafts/current/.</p>
<p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time.  It is inappropriate to use Internet-Drafts as reference material or to cite them other than as "work in progress."</p>
<p>This Internet-Draft will expire on May 3, 2018.</p>
<h1 id="rfc.copyrightnotice"><a href="#rfc.copyrightnotice">Copyright Notice</a></h1>
<p>Copyright (c) 2017 IETF Trust and the persons identified as the document authors.  All rights reserved.</p>
<p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document.  Please review these documents carefully, as they describe your rights and restrictions with respect to this document.  Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p>

  
  <hr class="noprint" />
  <h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1>
  <ul class="toc">

  	<li>1.   <a href="#rfc.section.1">Introduction</a>
</li>
<ul><li>1.1.   <a href="#rfc.section.1.1">Server Certificate Authentication</a>
</li>
<li>1.2.   <a href="#rfc.section.1.2">Client Certificate Authentication</a>
</li>
<ul><li>1.2.1.   <a href="#rfc.section.1.2.1">HTTP/1.1 using TLS 1.2 and previous</a>
</li>
<li>1.2.2.   <a href="#rfc.section.1.2.2">HTTP/1.1 using TLS 1.3</a>
</li>
<li>1.2.3.   <a href="#rfc.section.1.2.3">HTTP/2</a>
</li>
</ul><li>1.3.   <a href="#rfc.section.1.3">HTTP-Layer Certificate Authentication</a>
</li>
<li>1.4.   <a href="#rfc.section.1.4">Terminology</a>
</li>
</ul><li>2.   <a href="#rfc.section.2">Discovering Additional Certificates at the HTTP/2 Layer</a>
</li>
<ul><li>2.1.   <a href="#rfc.section.2.1">Indicating support for HTTP-layer certificate authentication</a>
</li>
<li>2.2.   <a href="#rfc.section.2.2">Making certificates or requests available</a>
</li>
<li>2.3.   <a href="#rfc.section.2.3">Requiring certificate authentication</a>
</li>
</ul><li>3.   <a href="#rfc.section.3">Certificates Frames for HTTP/2</a>
</li>
<ul><li>3.1.   <a href="#rfc.section.3.1">The CERTIFICATE_NEEDED frame</a>
</li>
<li>3.2.   <a href="#rfc.section.3.2">The USE_CERTIFICATE Frame</a>
</li>
<li>3.3.   <a href="#rfc.section.3.3">The CERTIFICATE_REQUEST Frame</a>
</li>
<li>3.4.   <a href="#rfc.section.3.4">The CERTIFICATE Frame</a>
</li>
<ul><li>3.4.1.   <a href="#rfc.section.3.4.1">Exported Authenticator Characteristics</a>
</li>
</ul></ul><li>4.   <a href="#rfc.section.4">Indicating failures during HTTP-Layer Certificate Authentication</a>
</li>
<li>5.   <a href="#rfc.section.5">Security Considerations</a>
</li>
<ul><li>5.1.   <a href="#rfc.section.5.1">Impersonation</a>
</li>
<li>5.2.   <a href="#rfc.section.5.2">Fingerprinting</a>
</li>
<li>5.3.   <a href="#rfc.section.5.3">Denial of Service</a>
</li>
<li>5.4.   <a href="#rfc.section.5.4">Confusion About State</a>
</li>
</ul><li>6.   <a href="#rfc.section.6">IANA Considerations</a>
</li>
<ul><li>6.1.   <a href="#rfc.section.6.1">HTTP/2 SETTINGS_HTTP_CERT_AUTH Setting</a>
</li>
<li>6.2.   <a href="#rfc.section.6.2">New HTTP/2 Frames</a>
</li>
<li>6.3.   <a href="#rfc.section.6.3">New HTTP/2 Error Codes</a>
</li>
</ul><li>7.   <a href="#rfc.section.7">Acknowledgements</a>
</li>
<li>8.   <a href="#rfc.references">References</a>
</li>
<ul><li>8.1.   <a href="#rfc.references.1">Normative References</a>
</li>
<li>8.2.   <a href="#rfc.references.2">Informative References</a>
</li>
</ul><li><a href="#rfc.authors">Authors' Addresses</a>
</li>


  </ul>

  <h1 id="rfc.section.1">
<a href="#rfc.section.1">1.</a> <a href="#introduction" id="introduction">Introduction</a>
</h1>
<p id="rfc.section.1.p.1">HTTP clients need to know that the content they receive on a connection comes from the origin that they intended to retrieve in from. The traditional form of server authentication in HTTP has been in the form of X.509 certificates provided during the TLS <a href="#I-D.ietf-tls-tls13" class="xref">RFC5246</a> handshake.</p>
<p id="rfc.section.1.p.2">Many existing HTTP <a href="#RFC7230" class="xref">[RFC7230]</a> servers also have authentication requirements for the resources they serve.  Of the bountiful authentication options available for authenticating HTTP requests, client certificates present a unique challenge for resource-specific authentication requirements because of the interaction with the underlying TLS layer.</p>
<p id="rfc.section.1.p.3">TLS 1.2 <a href="#RFC5246" class="xref">[RFC5246]</a> supports one server and one client certificate on a connection. These certificates may contain multiple identities, but only one certificate may be provided.</p>
<h1 id="rfc.section.1.1">
<a href="#rfc.section.1.1">1.1.</a> <a href="#server-certificate-authentication" id="server-certificate-authentication">Server Certificate Authentication</a>
</h1>
<p id="rfc.section.1.1.p.1">Section 9.1.1 of <a href="#RFC7540" class="xref">[RFC7540]</a> describes how connections may be used to make requests from multiple origins as long as the server is authoritative for both. A server is considered authoritative for an origin if DNS resolves the origin to the IP address of the server and (for TLS) if the certificate presented by the server contains the origin in the Subject Alternative Names field.</p>
<p><a href="#RFC7838" class="xref">[RFC7838]</a> enables a step of abstraction from the DNS resolution. If both hosts have provided an Alternative Service at hostnames which resolve to the IP address of the server, they are considered authoritative just as if DNS resolved the origin itself to that address. However, the server&#8217;s one TLS certificate is still required to contain the name of each origin in question.</p>
<p><a href="#I-D.ietf-httpbis-origin-frame" class="xref">[I-D.ietf-httpbis-origin-frame]</a> relaxes the requirement to perform the DNS lookup if already connected to a server with an appropriate certificate which claims support for a particular origin.</p>
<p id="rfc.section.1.1.p.4">Servers which host many origins often would prefer to have separate certificates for some sets of origins. This may be for ease of certificate management (the ability to separately revoke or renew them), due to different sources of certificates (a CDN acting on behalf of multiple origins), or other factors which might drive this administrative decision. Clients connecting to such origins cannot currently reuse connections, even if both client and server would prefer to do so.</p>
<p id="rfc.section.1.1.p.5">Because the TLS SNI extension is exchanged in the clear, clients might also prefer to retrieve certificates inside the encrypted context. When this information is sensitive, it might be advantageous to request a general-purpose certificate or anonymous ciphersuite at the TLS layer, while acquiring the &#8220;real&#8221; certificate in HTTP after the connection is established.</p>
<h1 id="rfc.section.1.2">
<a href="#rfc.section.1.2">1.2.</a> <a href="#client-certificate-authentication" id="client-certificate-authentication">Client Certificate Authentication</a>
</h1>
<p id="rfc.section.1.2.p.1">For servers that wish to use client certificates to authenticate users, they might request client authentication during or immediately after the TLS handshake. However, if not all users or resources need certificate-based authentication, a request for a certificate has the unfortunate consequence of triggering the client to seek a certificate, possibly requiring user interaction, network traffic, or other time-consuming activities. During this time, the connection is stalled in many implementations. Such a request can result in a poor experience, particularly when sent to a client that does not expect the request.</p>
<p id="rfc.section.1.2.p.2">The TLS 1.3 CertificateRequest can be used by servers to give clients hints about which certificate to offer. Servers that rely on certificate-based authentication might request different certificates for different resources. Such a server cannot use contextual information about the resource to construct an appropriate TLS CertificateRequest message during the initial handshake.</p>
<p id="rfc.section.1.2.p.3">Consequently, client certificates are requested at connection establishment time only in cases where all clients are expected or required to have a single certificate that is used for all resources.  Many other uses for client certificates are reactive, that is, certificates are requested in response to the client making a request.</p>
<h1 id="rfc.section.1.2.1">
<a href="#rfc.section.1.2.1">1.2.1.</a> <a href="#http11-using-tls-12-and-previous" id="http11-using-tls-12-and-previous">HTTP/1.1 using TLS 1.2 and previous</a>
</h1>
<p id="rfc.section.1.2.1.p.1">In HTTP/1.1, a server that relies on client authentication for a subset of users or resources does not request a certificate when the connection is established.  Instead, it only requests a client certificate when a request is made to a resource that requires a certificate.  TLS 1.2 <a href="#RFC5246" class="xref">[RFC5246]</a> accomodates this by permitting the server to request a new TLS handshake, in which the server will request the client&#8217;s certificate.</p>
<p><a href="#ex-http11" class="xref">Figure 1</a> shows the server initiating a TLS-layer renegotiation in response to receiving an HTTP/1.1 request to a protected resource.</p>
<div id="rfc.figure.1"></div>
<div id="ex-http11"></div>
<pre>
Client                                      Server
   -- (HTTP) GET /protected -------------------&gt; *1
   &lt;---------------------- (TLS) HelloRequest -- *2
   -- (TLS) ClientHello -----------------------&gt;
   &lt;------------------ (TLS) ServerHello, ... --
   &lt;---------------- (TLS) CertificateRequest -- *3
   -- (TLS) ..., Certificate ------------------&gt; *4
   -- (TLS) Finished --------------------------&gt;
   &lt;-------------------------- (TLS) Finished --
   &lt;--------------------------- (HTTP) 200 OK -- *5
</pre>
<p class="figure">Figure 1: HTTP/1.1 Reactive Certificate Authentication with TLS 1.2</p>
<p id="rfc.section.1.2.1.p.3">In this example, the server receives a request for a protected resource (at *1 on <a href="#ex-http11" class="xref">Figure 1</a>).  Upon performing an authorization check, the server determines that the request requires authentication using a client certificate and that no such certificate has been provided.</p>
<p id="rfc.section.1.2.1.p.4">The server initiates TLS renegotiation by sending a TLS HelloRequest (at *2).  The client then initiates a TLS handshake.  Note that some TLS messages are elided from the figure for the sake of brevity.</p>
<p id="rfc.section.1.2.1.p.5">The critical messages for this example are the server requesting a certificate with a TLS CertificateRequest (*3); this request might use information about the request or resource.  The client then provides a certificate and proof of possession of the private key in Certificate and CertificateVerify messages (*4).</p>
<p id="rfc.section.1.2.1.p.6">When the handshake completes, the server performs any authorization checks a second time.  With the client certificate available, it then authorizes the request and provides a response (*5).</p>
<h1 id="rfc.section.1.2.2">
<a href="#rfc.section.1.2.2">1.2.2.</a> <a href="#http11-using-tls-13" id="http11-using-tls-13">HTTP/1.1 using TLS 1.3</a>
</h1>
<p id="rfc.section.1.2.2.p.1">TLS 1.3 <a href="#I-D.ietf-tls-tls13" class="xref">[I-D.ietf-tls-tls13]</a> introduces a new client authentication mechanism that allows for clients to authenticate after the handshake has been completed.  For the purposes of authenticating an HTTP request, this is functionally equivalent to renegotiation.  <a href="#ex-tls13" class="xref">Figure 2</a> shows the simpler exchange this enables.</p>
<div id="rfc.figure.2"></div>
<div id="ex-tls13"></div>
<pre>
Client                                      Server
   -- (HTTP) GET /protected -------------------&gt;
   &lt;---------------- (TLS) CertificateRequest --
   -- (TLS) Certificate, CertificateVerify,
               Finished -----------------------&gt;
   &lt;--------------------------- (HTTP) 200 OK --
</pre>
<p class="figure">Figure 2: HTTP/1.1 Reactive Certificate Authentication with TLS 1.3</p>
<p id="rfc.section.1.2.2.p.2">TLS 1.3 does not support renegotiation, instead supporting direct client authentication.  In contrast to the TLS 1.2 example, in TLS 1.3, a server can simply request a certificate.</p>
<h1 id="rfc.section.1.2.3">
<a href="#rfc.section.1.2.3">1.2.3.</a> <a href="#http2" id="http2">HTTP/2</a>
</h1>
<p id="rfc.section.1.2.3.p.1">An important part of the HTTP/1.1 exchange is that the client is able to easily identify the request that caused the TLS renegotiation.  The client is able to assume that the next unanswered request on the connection is responsible.  The HTTP stack in the client is then able to direct the certificate request to the application or component that initiated that request.  This ensures that the application has the right contextual information for processing the request.</p>
<p id="rfc.section.1.2.3.p.2">In HTTP/2, a client can have multiple outstanding requests.  Without some sort of correlation information, a client is unable to identify which request caused the server to request a certificate.</p>
<p id="rfc.section.1.2.3.p.3">Thus, the minimum necessary mechanism to support reactive certificate authentication in HTTP/2 is an identifier that can be use to correlate an HTTP request with a request for a certificate.  Since streams are used for individual requests, correlation with a stream is sufficient.</p>
<p><a href="#RFC7540" class="xref">[RFC7540]</a> prohibits renegotiation after any application data has been sent.  This completely blocks reactive certificate authentication in HTTP/2 using TLS 1.2. If this restriction were relaxed by an extension or update to HTTP/2, such an identifier could be added to TLS 1.2 by means of an extension to TLS.  Unfortunately, many TLS 1.2 implementations do not permit application data to continue during a renegotiation. This is problematic for a multiplexed protocol like HTTP/2.</p>
<h1 id="rfc.section.1.3">
<a href="#rfc.section.1.3">1.3.</a> <a href="#http-layer-certificate-authentication" id="http-layer-certificate-authentication">HTTP-Layer Certificate Authentication</a>
</h1>
<p id="rfc.section.1.3.p.1">This draft defines HTTP/2 frames to carry the relevant certificate messages, enabling certificate-based authentication of both clients and servers independent of TLS version. This mechanism can be implemented at the HTTP layer without breaking the existing interface between HTTP and applications above it.</p>
<p id="rfc.section.1.3.p.2">This could be done in a naive manner by replicating the TLS messages as HTTP/2 frames on each stream. However, this would create needless redundancy between streams and require frequent expensive signing operations. Instead, TLS Exported Authenticators <a href="#I-D.ietf-tls-exported-authenticator" class="xref">[I-D.ietf-tls-exported-authenticator]</a> are exchanged on stream zero and the on-stream frames incorporate them by reference as needed.</p>
<p id="rfc.section.1.3.p.3">TLS Exported Authenticators are structured messages that can be exported by either party of a TLS connection and validated by the other party. An authenticator message can be constructed by either the client or the server given an established TLS connection, a certificate, and a corresponding private key.  Exported Authenticators use the message structures from section 4.4 of <a href="#I-D.ietf-tls-tls13" class="xref">[I-D.ietf-tls-tls13]</a>, but different parameters.</p>
<p id="rfc.section.1.3.p.4">Each Authenticator is computed using a Handshake Context and Finished MAC Key derived from the TLS session.  The Handshake Context is identical for both parties of the TLS connection, while the Finished MAC Key is dependent on whether the Authenticator is created by the client or the server.</p>
<p id="rfc.section.1.3.p.5">Successfully verified Authenticators result in certificate chains, with verified possession of the corresponding private key, which can be supplied into a collection of available certificates. Likewise, descriptions of desired certificates can be supplied into these collections. These pre-supplied elements are then available for automatic use (in some situations) or for reference by individual streams.</p>
<p><a href="#discovery" class="xref">Section 2</a> describes how the feature is employed, defining means to detect support in peers (<a href="#setting" class="xref">Section 2.1</a>), make certificates and requests available (<a href="#cert-available" class="xref">Section 2.2</a>), and indicate when streams are blocked waiting on an appropriate certificate (<a href="#cert-challenge" class="xref">Section 2.3</a>). <a href="#certs-http2" class="xref">Section 3</a> defines the required frame types, which parallel the TLS 1.3 message exchange. Finally, <a href="#errors" class="xref">Section 4</a> defines new error types which can be used to notify peers when the exchange has not been successful.</p>
<h1 id="rfc.section.1.4">
<a href="#rfc.section.1.4">1.4.</a> <a href="#terminology" id="terminology">Terminology</a>
</h1>
<p id="rfc.section.1.4.p.1">RFC 2119 <a href="#RFC2119" class="xref">[RFC2119]</a> defines the terms &#8220;MUST&#8221;, &#8220;MUST NOT&#8221;, &#8220;SHOULD&#8221; and &#8220;MAY&#8221;.</p>
<h1 id="rfc.section.2">
<a href="#rfc.section.2">2.</a> <a href="#discovery" id="discovery">Discovering Additional Certificates at the HTTP/2 Layer</a>
</h1>
<p id="rfc.section.2.p.1">A certificate chain with proof of possession of the private key corresponding to the end-entity certificate is sent as a single <samp>CERTIFICATE</samp> frame (see <a href="#http-cert" class="xref">Section 3.4</a>) on stream zero. Once the holder of a certificate has sent the chain and proof, this certificate chain is cached by the recipient and available for future use. If the certificate is marked as <samp>AUTOMATIC_USE</samp>, the certificate may be used by the recipient to authorize any current or future request.  Otherwise, the recipient requests the required certificate on each stream, but the previously-supplied certificates are available for reference without having to resend them.</p>
<p id="rfc.section.2.p.2">Likewise, the details of a request are sent on stream zero and stored by the recipient. These details will be referenced by subsequent <samp>CERTIFICATE_NEEDED</samp> frames.</p>
<p id="rfc.section.2.p.3">Data sent by each peer is correlated by the ID given in each frame.  This ID is unrelated to values used by the other peer, even if each uses the same ID in certain cases.</p>
<h1 id="rfc.section.2.1">
<a href="#rfc.section.2.1">2.1.</a> <a href="#setting" id="setting">Indicating support for HTTP-layer certificate authentication</a>
</h1>
<p id="rfc.section.2.1.p.1">Clients and servers that will accept requests for HTTP-layer certificate authentication indicate this using the HTTP/2 <samp>SETTINGS_HTTP_CERT_AUTH</samp> (0xSETTING-TBD) setting.</p>
<p id="rfc.section.2.1.p.2">The initial value for the <samp>SETTINGS_HTTP_CERT_AUTH</samp> setting is 0, indicating that the peer does not support HTTP-layer certificate authentication.  If a peer does support HTTP-layer certificate authentication, the value is 1.</p>
<h1 id="rfc.section.2.2">
<a href="#rfc.section.2.2">2.2.</a> <a href="#cert-available" id="cert-available">Making certificates or requests available</a>
</h1>
<p id="rfc.section.2.2.p.1">When a peer has advertised support for HTTP-layer certificates as in <a href="#setting" class="xref">Section 2.1</a>, either party can supply additional certificates into the connection at any time. These certificates then become available for the peer to consider when deciding whether a connection is suitable to transport a particular request.</p>
<p id="rfc.section.2.2.p.2">Available certificates which have the <samp>AUTOMATIC_USE</samp> flag set MAY be used by the recipient without further notice. This means that clients or servers which predict a certificate will be required could pre-supply the certificate without being asked. Regardless of whether <samp>AUTOMATIC_USE</samp> is set, these certificates are available for reference by future <samp>USE_CERTIFICATE</samp> frames.</p>
<div id="rfc.figure.3"></div>
<div id="ex-http2-server-proactive"></div>
<pre>
Client                                      Server
   &lt;-------- (stream 0) CERTIFICATE (AU flag) --
   ...
   -- (stream N) GET /from-new-origin ---------&gt;
   &lt;----------------------- (stream N) 200 OK --

</pre>
<p class="figure">Figure 3: Proactive Server Certificate</p>
<div id="rfc.figure.4"></div>
<div id="ex-http2-client-proactive"></div>
<pre>
Client                                      Server
   -- (stream 0) CERTIFICATE (AU flag) --------&gt;
   -- (streams 1,3) GET /protected ------------&gt;
   &lt;-------------------- (streams 1,3) 200 OK --

</pre>
<p class="figure">Figure 4: Proactive Client Certificate</p>
<p id="rfc.section.2.2.p.3">Likewise, either party can supply a <samp>CERTIFICATE_REQUEST</samp> that outlines parameters of a certificate they might request in the future.  It is important to note that this does not currently request such a certificate, but makes the contents of the request available for reference by a future <samp>CERTIFICATE_NEEDED</samp> frame.</p>
<h1 id="rfc.section.2.3">
<a href="#rfc.section.2.3">2.3.</a> <a href="#cert-challenge" id="cert-challenge">Requiring certificate authentication</a>
</h1>
<p id="rfc.section.2.3.p.1">As defined in <a href="#RFC7540" class="xref">[RFC7540]</a>, when a client finds that a https:// origin (or Alternative Service <a href="#RFC7838" class="xref">[RFC7838]</a>) to which it needs to make a request has the same IP address as a server to which it is already connected, it MAY check whether the TLS certificate provided contains the new origin as well, and if so, reuse the connection.</p>
<p id="rfc.section.2.3.p.2">If the TLS certificate does not contain the new origin, but the server has claimed support for that origin (with an ORIGIN frame, see <a href="#I-D.ietf-httpbis-origin-frame" class="xref">[I-D.ietf-httpbis-origin-frame]</a>) and advertised support for HTTP-layer certificates (see <a href="#setting" class="xref">Section 2.1</a>), it MAY send a <samp>CERTIFICATE_NEEDED</samp> frame on the stream it will use to make the request. (If the request parameters have not already been made available using a <samp>CERTIFICATE_REQUEST</samp> frame, the client will need to send the <samp>CERTIFICATE_REQUEST</samp> in order to generate the <samp>CERTIFICATE_NEEDED</samp> frame.) The stream represents a pending request to that origin which is blocked until a valid certificate is processed.</p>
<p id="rfc.section.2.3.p.3">The request is blocked until the server has responded with a <samp>USE_CERTIFICATE</samp> frame pointing to a certificate for that origin. If the certificate is already available, the server SHOULD immediately respond with the appropriate <samp>USE_CERTIFICATE</samp> frame. (If the certificate has not already been transmitted, the server will need to make the certificate available as described in <a href="#cert-available" class="xref">Section 2.2</a> before completing the exchange.)</p>
<p id="rfc.section.2.3.p.4">If the server does not have the desired certificate, it MUST respond with an empty <samp>USE_CERTIFICATE</samp> frame. In this case, or if the server has not advertised support for HTTP-layer certificates, the client MUST NOT send any requests for resources in that origin on the current connection.</p>
<div id="rfc.figure.5"></div>
<div id="ex-http2-server-requested"></div>
<pre>
Client                                      Server
   &lt;----------------------- (stream 0) ORIGIN --
   -- (stream 0) CERTIFICATE_REQUEST ----------&gt;
   ...
   -- (stream N) CERTIFICATE_NEEDED -----------&gt;
   &lt;------------------ (stream 0) CERTIFICATE --
   &lt;-------------- (stream N) USE_CERTIFICATE --
   -- (stream N) GET /from-new-origin ---------&gt;
   &lt;----------------------- (stream N) 200 OK --

</pre>
<p class="figure">Figure 5: Client-Requested Certificate</p>
<p id="rfc.section.2.3.p.5">Likewise, on each stream where certificate authentication is required, the server sends a <samp>CERTIFICATE_NEEDED</samp> frame, which the client answers with a <samp>USE_CERTIFICATE</samp> frame indicating the certificate to use. If the request parameters or the responding certificate are not already available, they will need to be sent as described in <a href="#cert-available" class="xref">Section 2.2</a> as part of this exchange.</p>
<div id="rfc.figure.6"></div>
<div id="ex-http2-client-requested"></div>
<pre>
Client                                      Server
   &lt;---------- (stream 0) CERTIFICATE_REQUEST --
   ...
   -- (stream N) GET /protected ---------------&gt;
   &lt;----------- (stream N) CERTIFICATE_NEEDED --
   -- (stream 0) CERTIFICATE ------------------&gt;
   -- (stream N) USE_CERTIFICATE --------------&gt;
   &lt;----------------------- (stream N) 200 OK --

</pre>
<p class="figure">Figure 6: Reactive Certificate Authentication</p>
<p id="rfc.section.2.3.p.6">A server SHOULD provide certificates for an origin before pushing resources from it or supplying content referencing the origin. If a client receives a <samp>PUSH_PROMISE</samp> referencing an origin for which it has not yet received the server&#8217;s certificate, the client MUST verify the server&#8217;s possession of an appropriate certificate by sending a <samp>CERTIFICATE_NEEDED</samp> frame on the pushed stream to inform the server that progress is blocked until the request is satisfied. The client MUST NOT use the pushed resource until an appropriate certificate has been received and validated.</p>
<h1 id="rfc.section.3">
<a href="#rfc.section.3">3.</a> <a href="#certs-http2" id="certs-http2">Certificates Frames for HTTP/2</a>
</h1>
<p id="rfc.section.3.p.1">The <samp>CERTIFICATE_REQUEST</samp> and <samp>CERTIFICATE_NEEDED</samp> frames are correlated by their <samp>Request-ID</samp> field. Subsequent <samp>CERTIFICATE_NEEDED</samp> frames with the same <samp>Request-ID</samp> value MAY be sent on other streams where the sender is expecting a certificate with the same parameters.</p>
<p id="rfc.section.3.p.2">The <samp>CERTIFICATE</samp>, and <samp>USE_CERTIFICATE</samp> frames are correlated by their <samp>Cert-ID</samp> field. Subsequent <samp>USE_CERTIFICATE</samp> frames with the same <samp>Cert-ID</samp> MAY be sent in response to other <samp>CERTIFICATE_NEEDED</samp> frames and refer to the same certificate.</p>
<p><samp>Request-ID</samp> and <samp>Cert-ID</samp> are sender-local, and the use of the same value by the other peer does not imply any correlation between their frames. These values MUST be unique per sender over the lifetime of the connection.</p>
<h1 id="rfc.section.3.1">
<a href="#rfc.section.3.1">3.1.</a> <a href="#http-cert-needed" id="http-cert-needed">The CERTIFICATE_NEEDED frame</a>
</h1>
<p id="rfc.section.3.1.p.1">The <samp>CERTIFICATE_NEEDED</samp> frame (0xFRAME-TBD1) is sent to indicate that the HTTP request on the current stream is blocked pending certificate authentication. The frame includes a request identifier which can be used to correlate the stream with a previous <samp>CERTIFICATE_REQUEST</samp> frame sent on stream zero. The <samp>CERTIFICATE_REQUEST</samp> describes the certificate the sender requires to make progress on the stream in question.</p>
<p id="rfc.section.3.1.p.2">The <samp>CERTIFICATE_NEEDED</samp> frame contains 2 octets, which is the authentication request identifier, <samp>Request-ID</samp>. A peer that receives a <samp>CERTIFICATE_NEEDED</samp> of any other length MUST treat this as a stream error of type <samp>PROTOCOL_ERROR</samp>. Frames with identical request identifiers refer to the same <samp>CERTIFICATE_REQUEST</samp>.</p>
<p id="rfc.section.3.1.p.3">A server MAY send multiple <samp>CERTIFICATE_NEEDED</samp> frames on the same stream. If a server requires that a client provide multiple certificates before authorizing a single request, each required certificate MUST be indicated with a separate <samp>CERTIFICATE_NEEDED</samp> frame, each of which MUST have a different request identifier (referencing different <samp>CERTIFICATE_REQUEST</samp> frames describing each required certificate). To reduce the risk of client confusion, servers SHOULD NOT have multiple outstanding <samp>CERTIFICATE_NEEDED</samp> frames on the same stream at any given time.</p>
<p id="rfc.section.3.1.p.4">Clients MUST NOT send multiple <samp>CERTIFICATE_NEEDED</samp> frames on the same stream.</p>
<p id="rfc.section.3.1.p.5">The <samp>CERTIFICATE_NEEDED</samp> frame MUST NOT be sent to a peer which has not advertised support for HTTP-layer certificate authentication.</p>
<p id="rfc.section.3.1.p.6">The <samp>CERTIFICATE_NEEDED</samp> frame MUST NOT be sent on stream zero, and MUST NOT be sent on a stream in the &#8220;half-closed (local)&#8221; state <a href="#RFC7540" class="xref">[RFC7540]</a>. A client that receives a <samp>CERTIFICATE_NEEDED</samp> frame on a stream which is not in a valid state SHOULD treat this as a stream error of type <samp>PROTOCOL_ERROR</samp>.</p>
<h1 id="rfc.section.3.2">
<a href="#rfc.section.3.2">3.2.</a> <a href="#http-use-certificate" id="http-use-certificate">The USE_CERTIFICATE Frame</a>
</h1>
<p id="rfc.section.3.2.p.1">The <samp>USE_CERTIFICATE</samp> frame (0xFRAME-TBD4) is sent in response to a <samp>CERTIFICATE_NEEDED</samp> frame to indicate which certificate is being used to satisfy the requirement.</p>
<p id="rfc.section.3.2.p.2">A <samp>USE_CERTIFICATE</samp> frame with no payload refers to the certificate provided at the TLS layer, if any. If no certificate was provided at the TLS layer, the stream should be processed with no authentication, likely returning an authentication-related error at the HTTP level (e.g. 403) for servers or routing the request to a new connection for clients.</p>
<p id="rfc.section.3.2.p.3">Otherwise, the <samp>USE_CERTIFICATE</samp> frame contains the two-octet <samp>Cert-ID</samp> of the certificate the sender wishes to use. This MUST be the ID of a certificate for which proof of possession has been presented in a <samp>CERTIFICATE</samp> frame.  Recipients of a <samp>USE_CERTIFICATE</samp> frame of any other length MUST treat this as a stream error of type <samp>PROTOCOL_ERROR</samp>. Frames with identical certificate identifiers refer to the same certificate chain.</p>
<p id="rfc.section.3.2.p.4">The <samp>USE_CERTIFICATE</samp> frame MUST NOT be sent on stream zero or a stream on which a <samp>CERTIFICATE_NEEDED</samp> frame has not been received. Receipt of a <samp>USE_CERTIFICATE</samp> frame in these circumstances SHOULD be treated as a stream error of type <samp>PROTOCOL_ERROR</samp>. Each <samp>USE_CERTIFICATE</samp> frame should reference a preceding <samp>CERTIFICATE</samp> frame. Receipt of a <samp>USE_CERTIFICATE</samp> frame before the necessary frames have been received on stream zero MUST also result in a stream error of type <samp>PROTOCOL_ERROR</samp>.</p>
<p id="rfc.section.3.2.p.5">The referenced certificate chain MUST conform to the requirements expressed in the <samp>CERTIFICATE_REQUEST</samp> to the best of the sender&#8217;s ability. Specifically, if the <samp>CERTIFICATE_REQUEST</samp> contained a non-empty <samp>Cert-Extensions</samp> element, the end-entity certificate MUST match with regard to the extensions recognized by the sender.</p>
<p id="rfc.section.3.2.p.6">If these requirements are not satisfied, the recipient MAY at its discretion either return an error at the HTTP semantic layer, or respond with a stream error <a href="#RFC7540" class="xref">[RFC7540]</a> on any stream where the certificate is used. <a href="#errors" class="xref">Section 4</a> defines certificate-related error codes which might be applicable.</p>
<h1 id="rfc.section.3.3">
<a href="#rfc.section.3.3">3.3.</a> <a href="#http-cert-request" id="http-cert-request">The CERTIFICATE_REQUEST Frame</a>
</h1>
<p id="rfc.section.3.3.p.1">TLS 1.3 defines the <samp>CertificateRequest</samp> message, which prompts the client to provide a certificate which conforms to certain properties specified by the server.  This draft defines the <samp>CERTIFICATE_REQUEST</samp> frame (0xFRAME-TBD2), which uses the same set of extensions to specify a desired certificate, but can be sent over any TLS version and can be sent by either peer.</p>
<p id="rfc.section.3.3.p.2">The <samp>CERTIFICATE_REQUEST</samp> frame SHOULD NOT be sent to a peer which has not advertised support for HTTP-layer certificate authentication.</p>
<p id="rfc.section.3.3.p.3">The <samp>CERTIFICATE_REQUEST</samp> frame MUST be sent on stream zero.  A <samp>CERTIFICATE_REQUEST</samp> frame received on any other stream MUST be rejected with a stream error of type <samp>PROTOCOL_ERROR</samp>.</p>
<div id="rfc.figure.7"></div>
<div id="fig-cert-request"></div>
<pre>
  0                   1                   2                   3
  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 +-------------------------------+-------------------------------+
 |        Request-ID (16)        |      Extension-Count (16)     |
 +-------------------------------+-------------------------------+
 |                          Extensions(?)                      ...
 +---------------------------------------------------------------+
</pre>
<p class="figure">Figure 7: CERTIFICATE_REQUEST frame payload</p>
<p id="rfc.section.3.3.p.4">The frame contains the following fields:</p>
<p></p>

<dl>
<dt>Request-ID:</dt>
<dd style="margin-left: 8">
<samp>Request-ID</samp> is a 16-bit opaque identifier used to correlate subsequent certificate-related frames with this request.  The identifier MUST be unique in the session for the sender.</dd>
<dt>Extension-Count and Extensions:</dt>
<dd style="margin-left: 8">A list of certificate selection criteria, represented in a series of <samp>Extension</samp> structures (see <a href="#I-D.ietf-tls-tls13" class="xref">[I-D.ietf-tls-tls13]</a> section 4.2). This criteria MUST be used in certificate selection as described in <a href="#I-D.ietf-tls-tls13" class="xref">[I-D.ietf-tls-tls13]</a>.  The number of <samp>Extension</samp> structures is given by the 16-bit <samp>Extension-Count</samp> field, which MAY be zero.</dd>
</dl>
<p id="rfc.section.3.3.p.6">Some extensions used for certificate selection allow multiple values (e.g.  oid_filters on Extended Key Usage). If the sender has included a non-empty Extensions list, the certificate MUST match all criteria specified by extensions the recipient recognizes. However, the recipient MUST ignore and skip any unrecognized certificate selection extensions.</p>
<p id="rfc.section.3.3.p.7">Servers MUST be able to recognize the <samp>server_name</samp> extension (<a href="#RFC6066" class="xref">[RFC6066]</a>) at a minimum. Clients MUST always specify the desired origin using this extension, though other extensions MAY also be included.</p>
<h1 id="rfc.section.3.4">
<a href="#rfc.section.3.4">3.4.</a> <a href="#http-cert" id="http-cert">The CERTIFICATE Frame</a>
</h1>
<p id="rfc.section.3.4.p.1">The <samp>CERTIFICATE</samp> frame (id=0xFRAME-TBD3) provides a exported authenticator message from the TLS layer that provides a chain of certificates, associated extensions and proves possession of the private key corresponding to the end-entity certificate.</p>
<p id="rfc.section.3.4.p.2">The <samp>CERTIFICATE</samp> frame defines two flags:</p>
<p></p>

<dl>
<dt>AUTOMATIC_USE (0x01):</dt>
<dd style="margin-left: 8">Indicates that the certificate can be used automatically on future requests.</dd>
<dt>TO_BE_CONTINUED (0x02):</dt>
<dd style="margin-left: 8">Indicates that the exported authenticator spans more than one frame.</dd>
</dl>
<div id="rfc.figure.8"></div>
<div id="fig-proof-frame"></div>
<pre>
  0                   1                   2                   3
  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 +-------------------------------+-------------------------------+
 |          Cert-ID (16)         |   Authenticator Fragment (*)...
 +---------------------------------------------------------------+
</pre>
<p class="figure">Figure 8: CERTIFICATE frame payload</p>
<p id="rfc.section.3.4.p.4">The <samp>Exported Authenticator Fragment</samp> field contains a portion of the opaque data returned from the TLS connection exported authenticator <samp>authenticate</samp> API.  See <a href="#exp-auth" class="xref">Section 3.4.1</a> for more details on the input to this API.</p>
<p id="rfc.section.3.4.p.5">This opaque data is transported in zero or more <samp>CERTIFICATE</samp> frames with the <samp>TO_BE_CONTINUED</samp> flag set, followed by one <samp>CERTIFICATE</samp> frame with the <samp>TO_BE_CONTINUED</samp> flag unset.  Each of these frames contains the same <samp>Cert-ID</samp> field, permitting them to be associated with each other.  Receipt of any <samp>CERTIFICATE</samp> frame with the same <samp>Cert-ID</samp> following the receipt of a <samp>CERTIFICATE</samp> frame with <samp>TO_BE_CONTINUED</samp> unset MUST be treated as a connection error of type <samp>PROTOCOL_ERROR</samp>.</p>
<p id="rfc.section.3.4.p.6">If the <samp>AUTOMATIC_USE</samp> flag is set, the recipient MAY omit sending <samp>CERTIFICATE_NEEDED</samp> frames on future streams which would require a similar certificate and use the referenced certificate for authentication without further notice to the holder. This behavior is optional, and receipt of a <samp>CERTIFICATE_NEEDED</samp> frame does not imply that previously-presented certificates were unacceptable, even if <samp>AUTOMATIC_USE</samp> was set. Servers MUST set the <samp>AUTOMATIC_USE</samp> flag when sending a <samp>CERTIFICATE</samp> frame. A server MUST NOT send certificates for origins which it is not prepared to service on the current connection.</p>
<p id="rfc.section.3.4.p.7">Upon receiving a complete series of <samp>CERTIFICATE</samp> frames, the receiver may validate the Exported Authenticator value by using the exported authenticator API. This returns either an error indicating that the message was invalid, or the certificate chain and extensions used to create the message.</p>
<p id="rfc.section.3.4.p.8">The <samp>CERTIFICATE</samp> frame MUST be sent on stream zero.  A <samp>CERTIFICATE</samp> frame received on any other stream MUST be rejected with a stream error of type <samp>PROTOCOL_ERROR</samp>.</p>
<h1 id="rfc.section.3.4.1">
<a href="#rfc.section.3.4.1">3.4.1.</a> <a href="#exp-auth" id="exp-auth">Exported Authenticator Characteristics</a>
</h1>
<p id="rfc.section.3.4.1.p.1">The Exported Authenticator API defined in <a href="#I-D.ietf-tls-exported-authenticator" class="xref">[I-D.ietf-tls-exported-authenticator]</a> takes as input a certificate, supporting information about the certificate (OCSP, SCT, etc.), and an optional <samp>certificate_request_context</samp>.  When generating exported authenticators for use with this extension, the <samp>certificate_request_context</samp> MUST be the two-octet Cert-ID.</p>
<p id="rfc.section.3.4.1.p.2">Upon receipt of a completed authenticator, an endpoint MUST check that:</p>
<p></p>

<ul>
<li>the <samp>validate</samp> API confirms the validity of the authenticator itself</li>
<li>the <samp>certificate_request_context</samp> matches the Cert-ID of the frame(s) in which it was received</li>
</ul>
<p id="rfc.section.3.4.1.p.4">Once the authenticator is accepted, the endpoint can perform any other checks for the acceptability of the certificate itself.</p>
<h1 id="rfc.section.4">
<a href="#rfc.section.4">4.</a> <a href="#errors" id="errors">Indicating failures during HTTP-Layer Certificate Authentication</a>
</h1>
<p id="rfc.section.4.p.1">Because this draft permits certificates to be exchanged at the HTTP framing layer instead of the TLS layer, several certificate-related errors which are defined at the TLS layer might now occur at the HTTP framing layer. In this section, those errors are restated and added to the HTTP/2 error code registry.</p>
<p></p>

<dl>
<dt>BAD_CERTIFICATE (0xERROR-TBD1):</dt>
<dd style="margin-left: 8">A certificate was corrupt, contained signatures that did not verify correctly, etc.</dd>
<dt>UNSUPPORTED_CERTIFICATE (0xERROR-TBD2):</dt>
<dd style="margin-left: 8">A certificate was of an unsupported type or did not contain required extensions</dd>
<dt>CERTIFICATE_REVOKED (0xERROR-TBD3):</dt>
<dd style="margin-left: 8">A certificate was revoked by its signer</dd>
<dt>CERTIFICATE_EXPIRED (0xERROR-TBD4):</dt>
<dd style="margin-left: 8">A certificate has expired or is not currently valid</dd>
<dt>CERTIFICATE_GENERAL (0xERROR-TBD5):</dt>
<dd style="margin-left: 8">Any other certificate-related error</dd>
</dl>
<p id="rfc.section.4.p.3">As described in <a href="#RFC7540" class="xref">[RFC7540]</a>, implementations MAY choose to treat a stream error as a connection error at any time. Of particular note, a stream error cannot occur on stream 0, which means that implementations cannot send non-session errors in response to <samp>CERTIFICATE_REQUEST</samp>, and <samp>CERTIFICATE</samp> frames. Implementations which do not wish to terminate the connection MAY either send relevant errors on any stream which references the failing certificate in question or process the requests as unauthenticated and provide error information at the HTTP semantic layer.</p>
<h1 id="rfc.section.5">
<a href="#rfc.section.5">5.</a> <a href="#security" id="security">Security Considerations</a>
</h1>
<p id="rfc.section.5.p.1">This mechanism defines an alternate way to obtain server and client certificates other than in the initial TLS handshake. While the signature of exported authenticator values is expected to be equally secure, it is important to recognize that a vulnerability in this code path is at least equal to a vulnerability in the TLS handshake.</p>
<h1 id="rfc.section.5.1">
<a href="#rfc.section.5.1">5.1.</a> <a href="#impersonation" id="impersonation">Impersonation</a>
</h1>
<p id="rfc.section.5.1.p.1">This mechanism could increase the impact of a key compromise. Rather than needing to subvert DNS or IP routing in order to use a compromised certificate, a malicious server now only needs a client to connect to <em>some</em> HTTPS site under its control in order to present the compromised certificate. As recommended in <a href="#I-D.ietf-httpbis-origin-frame" class="xref">[I-D.ietf-httpbis-origin-frame]</a>, clients opting not to consult DNS ought to employ some alternative means to increase confidence that the certificate is legitimate.</p>
<p id="rfc.section.5.1.p.2">As noted in the Security Considerations of <a href="#I-D.ietf-tls-exported-authenticator" class="xref">[I-D.ietf-tls-exported-authenticator]</a>, it difficult to formally prove that an endpoint is jointly authoritative over multiple certificates, rather than individually authoritative on each certificate.  As a result, clients MUST NOT assume that because one origin was previously colocated with another, those origins will be reachable via the same endpoints in the future.  Clients MUST NOT consider previous secondary certificates to be validated after TLS session resumption.  However, clients MAY proactively query for previously-presented secondary certificates.</p>
<h1 id="rfc.section.5.2">
<a href="#rfc.section.5.2">5.2.</a> <a href="#fingerprinting" id="fingerprinting">Fingerprinting</a>
</h1>
<p id="rfc.section.5.2.p.1">This draft defines a mechanism which could be used to probe servers for origins they support, but opens no new attack versus making repeat TLS connections with different SNI values. Servers SHOULD impose similar denial-of-service mitigations (e.g. request rate limits) to <samp>CERTIFICATE_REQUEST</samp> frames as to new TLS connections.</p>
<p id="rfc.section.5.2.p.2">While the extensions in the <samp>CERTIFICATE_REQUEST</samp> frame permit the sender to enumerate the acceptable Certificate Authorities for the requested certificate, it might not be prudent (either for security or data consumption) to include the full list of trusted Certificate Authorities in every request. Senders, particularly clients, SHOULD send only the extensions that narrowly specify which certificates would be acceptable.</p>
<h1 id="rfc.section.5.3">
<a href="#rfc.section.5.3">5.3.</a> <a href="#denial-of-service" id="denial-of-service">Denial of Service</a>
</h1>
<p id="rfc.section.5.3.p.1">Failure to provide a certificate on a stream after receiving <samp>CERTIFICATE_NEEDED</samp> blocks processing, and SHOULD be subject to standard timeouts used to guard against unresponsive peers.</p>
<p id="rfc.section.5.3.p.2">Validating a multitude of signatures can be computationally expensive, while generating an invalid signature is computationally cheap. Implementations will require checks for attacks from this direction. Invalid exported authenticators SHOULD be treated as a session error, to avoid further attacks from the peer, though an implementation MAY instead disable HTTP-layer certificates for the current connection instead.</p>
<h1 id="rfc.section.5.4">
<a href="#rfc.section.5.4">5.4.</a> <a href="#confusion-about-state" id="confusion-about-state">Confusion About State</a>
</h1>
<p id="rfc.section.5.4.p.1">Implementations need to be aware of the potential for confusion about the state of a connection. The presence or absence of a validated certificate can change during the processing of a request, potentially multiple times, as <samp>USE_CERTIFICATE</samp> frames are received. A server that uses certificate authentication needs to be prepared to reevaluate the authorization state of a request as the set of certificates changes.</p>
<p id="rfc.section.5.4.p.2">Client implementations need to carefully consider the impact of setting the <samp>AUTOMATIC_USE</samp> flag. This flag is a performance optimization, permitting the client to avoid a round-trip on each request where the server checks for certificate authentication. However, once this flag has been sent, the client has zero knowledge about whether the server will use the referenced cert for any future request, or even for an existing request which has not yet completed. Clients MUST NOT set this flag on any certificate which is not appropriate for currently-in-flight requests, and MUST NOT make any future requests on the same connection which they are not willing to have associated with the provided certificate.</p>
<h1 id="rfc.section.6">
<a href="#rfc.section.6">6.</a> <a href="#iana" id="iana">IANA Considerations</a>
</h1>
<p id="rfc.section.6.p.1">This draft adds entries in three registries.</p>
<p id="rfc.section.6.p.2">The HTTP/2 <samp>SETTINGS_HTTP_CERT_AUTH</samp> setting is registered in <a href="#iana-setting" class="xref">Section 6.1</a>.  Four frame types are registered in <a href="#iana-frame" class="xref">Section 6.2</a>.  Six error codes are registered in <a href="#iana-errors" class="xref">Section 6.3</a>.</p>
<h1 id="rfc.section.6.1">
<a href="#rfc.section.6.1">6.1.</a> <a href="#iana-setting" id="iana-setting">HTTP/2 SETTINGS_HTTP_CERT_AUTH Setting</a>
</h1>
<p id="rfc.section.6.1.p.1">The SETTINGS_HTTP_CERT_AUTH setting is registered in the &#8220;HTTP/2 Settings&#8221; registry established in <a href="#RFC7540" class="xref">[RFC7540]</a>.</p>
<p></p>

<dl>
<dt>Name:</dt>
<dd style="margin-left: 8">SETTINGS_HTTP_CERT_AUTH</dd>
<dt>Code:</dt>
<dd style="margin-left: 8">0xSETTING-TBD</dd>
<dt>Initial Value:</dt>
<dd style="margin-left: 8">0</dd>
<dt>Specification:</dt>
<dd style="margin-left: 8">This document.</dd>
</dl>
<h1 id="rfc.section.6.2">
<a href="#rfc.section.6.2">6.2.</a> <a href="#iana-frame" id="iana-frame">New HTTP/2 Frames</a>
</h1>
<p id="rfc.section.6.2.p.1">Four new frame types are registered in the &#8220;HTTP/2 Frame Types&#8221; registry established in <a href="#RFC7540" class="xref">[RFC7540]</a>. The entries in the following table are registered by this document.</p>
<table cellpadding="3" cellspacing="0" class="tt full center">
<thead><tr>
<th class="left">Frame Type</th>
<th class="left">Code</th>
<th class="left">Specification</th>
</tr></thead>
<tbody>
<tr>
<td class="left">CERTIFICATE_NEEDED</td>
<td class="left">0xFRAME-TBD1</td>
<td class="left"><a href="#http-cert-needed" class="xref">Section 3.1</a></td>
</tr>
<tr>
<td class="left">CERTIFICATE_REQUEST</td>
<td class="left">0xFRAME-TBD2</td>
<td class="left"><a href="#http-cert-request" class="xref">Section 3.3</a></td>
</tr>
<tr>
<td class="left">CERTIFICATE</td>
<td class="left">0xFRAME-TBD3</td>
<td class="left"><a href="#http-cert" class="xref">Section 3.4</a></td>
</tr>
<tr>
<td class="left">USE_CERTIFICATE</td>
<td class="left">0xFRAME-TBD4</td>
<td class="left"><a href="#http-use-certificate" class="xref">Section 3.2</a></td>
</tr>
</tbody>
</table>
<h1 id="rfc.section.6.3">
<a href="#rfc.section.6.3">6.3.</a> <a href="#iana-errors" id="iana-errors">New HTTP/2 Error Codes</a>
</h1>
<p id="rfc.section.6.3.p.1">Five new error codes are registered in the &#8220;HTTP/2 Error Code&#8221; registry established in <a href="#RFC7540" class="xref">[RFC7540]</a>. The entries in the following table are registered by this document.</p>
<table cellpadding="3" cellspacing="0" class="tt full center">
<thead><tr>
<th class="left">Name</th>
<th class="left">Code</th>
<th class="left">Specification</th>
</tr></thead>
<tbody>
<tr>
<td class="left">BAD_CERTIFICATE</td>
<td class="left">0xERROR-TBD1</td>
<td class="left"><a href="#errors" class="xref">Section 4</a></td>
</tr>
<tr>
<td class="left">UNSUPPORTED_CERTIFICATE</td>
<td class="left">0xERROR-TBD2</td>
<td class="left"><a href="#errors" class="xref">Section 4</a></td>
</tr>
<tr>
<td class="left">CERTIFICATE_REVOKED</td>
<td class="left">0xERROR-TBD3</td>
<td class="left"><a href="#errors" class="xref">Section 4</a></td>
</tr>
<tr>
<td class="left">CERTIFICATE_EXPIRED</td>
<td class="left">0xERROR-TBD4</td>
<td class="left"><a href="#errors" class="xref">Section 4</a></td>
</tr>
<tr>
<td class="left">CERTIFICATE_GENERAL</td>
<td class="left">0xERROR-TBD5</td>
<td class="left"><a href="#errors" class="xref">Section 4</a></td>
</tr>
</tbody>
</table>
<h1 id="rfc.section.7">
<a href="#rfc.section.7">7.</a> <a href="#ack" id="ack">Acknowledgements</a>
</h1>
<p id="rfc.section.7.p.1">Eric Rescorla pointed out several failings in an earlier revision.  Andrei Popov contributed to the TLS considerations.</p>
<h1 id="rfc.references">
<a href="#rfc.references">8.</a> References</h1>
<h1 id="rfc.references.1">
<a href="#rfc.references.1">8.1.</a> Normative References</h1>
<table><tbody>
<tr>
<td class="reference"><b id="I-D.ietf-tls-exported-authenticator">[I-D.ietf-tls-exported-authenticator]</b></td>
<td class="top">
<a>Sullivan, N.</a>, "<a href="https://tools.ietf.org/html/draft-ietf-tls-exported-authenticator-03">Exported Authenticators in TLS</a>", Internet-Draft draft-ietf-tls-exported-authenticator-03, July 2017.</td>
</tr>
<tr>
<td class="reference"><b id="I-D.ietf-tls-tls13">[I-D.ietf-tls-tls13]</b></td>
<td class="top">
<a>Rescorla, E.</a>, "<a href="https://tools.ietf.org/html/draft-ietf-tls-tls13-21">The Transport Layer Security (TLS) Protocol Version 1.3</a>", Internet-Draft draft-ietf-tls-tls13-21, July 2017.</td>
</tr>
<tr>
<td class="reference"><b id="RFC2119">[RFC2119]</b></td>
<td class="top">
<a>Bradner, S.</a>, "<a href="https://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997.</td>
</tr>
<tr>
<td class="reference"><b id="RFC2459">[RFC2459]</b></td>
<td class="top">
<a>Housley, R.</a>, <a>Ford, W.</a>, <a>Polk, W.</a> and <a>D. Solo</a>, "<a href="https://tools.ietf.org/html/rfc2459">Internet X.509 Public Key Infrastructure Certificate and CRL Profile</a>", RFC 2459, DOI 10.17487/RFC2459, January 1999.</td>
</tr>
<tr>
<td class="reference"><b id="RFC5246">[RFC5246]</b></td>
<td class="top">
<a>Dierks, T.</a> and <a>E. Rescorla</a>, "<a href="https://tools.ietf.org/html/rfc5246">The Transport Layer Security (TLS) Protocol Version 1.2</a>", RFC 5246, DOI 10.17487/RFC5246, August 2008.</td>
</tr>
<tr>
<td class="reference"><b id="RFC5280">[RFC5280]</b></td>
<td class="top">
<a>Cooper, D.</a>, <a>Santesson, S.</a>, <a>Farrell, S.</a>, <a>Boeyen, S.</a>, <a>Housley, R.</a> and <a>W. Polk</a>, "<a href="https://tools.ietf.org/html/rfc5280">Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile</a>", RFC 5280, DOI 10.17487/RFC5280, May 2008.</td>
</tr>
<tr>
<td class="reference"><b id="RFC6066">[RFC6066]</b></td>
<td class="top">
<a>Eastlake 3rd, D.</a>, "<a href="https://tools.ietf.org/html/rfc6066">Transport Layer Security (TLS) Extensions: Extension Definitions</a>", RFC 6066, DOI 10.17487/RFC6066, January 2011.</td>
</tr>
<tr>
<td class="reference"><b id="RFC7230">[RFC7230]</b></td>
<td class="top">
<a>Fielding, R.</a> and <a>J. Reschke</a>, "<a href="https://tools.ietf.org/html/rfc7230">Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing</a>", RFC 7230, DOI 10.17487/RFC7230, June 2014.</td>
</tr>
<tr>
<td class="reference"><b id="RFC7540">[RFC7540]</b></td>
<td class="top">
<a>Belshe, M.</a>, <a>Peon, R.</a> and <a>M. Thomson</a>, "<a href="https://tools.ietf.org/html/rfc7540">Hypertext Transfer Protocol Version 2 (HTTP/2)</a>", RFC 7540, DOI 10.17487/RFC7540, May 2015.</td>
</tr>
<tr>
<td class="reference"><b id="X690">[X690]</b></td>
<td class="top">
<a>ITU-T</a>, "<a href="http://www.itu.int/ITU-T/studygroups/com17/languages/X.690-0207.pdf">Information technology - ASN.1 encoding Rules: Specification of Basic Encoding Rules (BER), Canonical Encoding Rules (CER) and Distinguished Encoding Rules (DER)</a>", ISO ISO/IEC 8825-1:2002, 2002.</td>
</tr>
</tbody></table>
<h1 id="rfc.references.2">
<a href="#rfc.references.2">8.2.</a> Informative References</h1>
<table><tbody>
<tr>
<td class="reference"><b id="I-D.ietf-httpbis-origin-frame">[I-D.ietf-httpbis-origin-frame]</b></td>
<td class="top">
<a>Nottingham, M.</a> and <a>E. Nygren</a>, "<a href="https://tools.ietf.org/html/draft-ietf-httpbis-origin-frame-04">The ORIGIN HTTP/2 Frame</a>", Internet-Draft draft-ietf-httpbis-origin-frame-04, August 2017.</td>
</tr>
<tr>
<td class="reference"><b id="RFC7838">[RFC7838]</b></td>
<td class="top">
<a>Nottingham, M.</a>, <a>McManus, P.</a> and <a>J. Reschke</a>, "<a href="https://tools.ietf.org/html/rfc7838">HTTP Alternative Services</a>", RFC 7838, DOI 10.17487/RFC7838, April 2016.</td>
</tr>
</tbody></table>
<h1 id="rfc.authors"><a href="#rfc.authors">Authors' Addresses</a></h1>
<div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Mike Bishop</span> 
	  <span class="n hidden">
		<span class="family-name">Bishop</span>
	  </span>
	</span>
	<span class="org vcardline"></span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:mbishop@evequefou.be">mbishop@evequefou.be</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Nick Sullivan</span> 
	  <span class="n hidden">
		<span class="family-name">Sullivan</span>
	  </span>
	</span>
	<span class="org vcardline">Cloudflare</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:nick@cloudflare.com">nick@cloudflare.com</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Martin Thomson</span> 
	  <span class="n hidden">
		<span class="family-name">Thomson</span>
	  </span>
	</span>
	<span class="org vcardline">Mozilla</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:martin.thomson@gmail.com">martin.thomson@gmail.com</a></span>

  </address>
</div>

  <div class="github-fork-ribbon-wrapper"><div class="github-fork-ribbon"><a href="https://github.com/MikeBishop/http2-certs">Fork me on GitHub</a></div></div>
</body>
</html>
