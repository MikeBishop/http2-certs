<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head profile="http://www.w3.org/2006/03/hcard http://dublincore.org/documents/2008/08/04/dc-html/">
  <meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />

  <title>Secondary Certificate Authentication in HTTP/2</title>

  <style type="text/css">/*<![CDATA[*/
@viewport {
  zoom: 1.0;
  width: extend-to-zoom;
}
@-ms-viewport {
  width: extend-to-zoom;
  zoom: 1.0;
}

@media screen and (min-width: 1024px) {
  ul.toc, #rfc\.toc {
    position: fixed;
    bottom: 0;
    right: 0;
    right: calc(50vw - 500px);
    width: 300px;
    padding: 0 1em;
    z-index: 1;
  }
  #rfc\.toc {
    top: 16px;
  }
  ul.toc {
    top: 80px;
    overflow: auto;
  }

  body {
    padding-left: 1.5em;
    padding-right: 29em;
  }
}

body {
  font: 15px "Helvetica Neue",Helvetica,Arial,sans-serif;
  color: #333;
  font-size-adjust: 0.5;
  line-height: 130%;
  margin: 2.5em auto;
  max-width: 724px;
}

.title, .filename, h1, h2, h3, h4 {
  font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
  font-size-adjust: 0.5;
  font-weight: 500;
  color: #333;
  line-height: 100%;
  margin: 0.8em 0 0.3em;
}
.title { font-size: 36px; }
h1 { font-size: 30px; }
h2 { font-size: 24px; }
h3, h4 { font-size: 18px; }
h1 a[href], h2 a[href], h3 a[href], h4 a[href] {
  color: #333;
}

ul.toc li {
  list-style: none;
  text-indent: -2.5em;
  padding-left: 2.5em;
  padding-bottom: 5px;
  margin: 0;
}
ul.toc, ul.toc ul {
  margin: 0 0 0 1.5em;
}

table {
  margin-left: 0em;
  border-collapse: collapse;
}
th {
  text-align: left;
  border-bottom: 2px solid #ddd;
}
td {
  border-top: 1px solid #ddd;
  vertical-align: top;
}
tr:nth-child(2n+1) > td,
tr:nth-child(2n+1) > th {
  background-color: #f9f9f9;
}
td.reference {
  max-width: 200px;
  border-top: none;
  padding-right: 1em;
}
.right {
  text-align: right;
}


table.header {
  width: 100%;
}
table.header td {
  border: none;
  background-color: transparent;
  color: black;
}
.filename {
  color: rgb(119, 119, 119);
  font-size: 23px;
  font-weight: normal;
  height: auto;
  line-height: 100%;
}
#rfc\.abstract+p {
  font-size: 20px;
  font-weight: 300;
  line-height: 130%;
}

samp, tt, code, pre {
  font: 11pt consolas, monospace;
  font-size-adjust: none;
}
pre {
  background-color: #eee;
  border: 1px solid #ddd;
  overflow-x: auto;
  padding: 5px;
  margin: 5px;
}
.figure {
  font-style: italic;
  margin: 0 1.5em;
}

address {
  margin: 10px 0 0;
}
.vcard {
  font-style: normal;
}
.vcardline {
  display: block;
}
.vcardline .fn {
  font-weight: bold;
}
.vcardline .hidden {
  display: none;
}

dl {
  margin-left: 1em;
}
dl.dl-horizontal: {
  margin-left: 0;
}
dl > dt {
  float: left;
  margin-right: 1em;
}
dl.nohang > dt {
  float: none;
}
dl > dd {
  margin-bottom: .5em;
}
dl.compact > dd {
  margin-bottom: 0em;
}
dl > dd > dl {
  margin-top: 0.5em;
  margin-bottom: 0em;
}
ul.empty {
  list-style-type: none;
}
ul.empty li {
  margin-top: .5em;
}

hr {
  border: 0;
  border-top: 1px solid #eee;
}

a {
  text-decoration: none;
}
a[href] {
  color: #2a6496;
}
a[href]:hover {
  background-color: #eee;
}

ol, ul, li, p {
  padding: 0;
  margin: 0.5em 0 0.5em 2em;
}
li, p {
  margin-left: 0;
}

.github-fork-ribbon-wrapper {
  display: none;
}
@media screen and (min-width: 800px) {
  /* "Fork me on GitHub" CSS ribbon based on
   * https://github.com/simonwhitaker/github-fork-ribbon-css
   */
  .github-fork-ribbon {
    position: absolute;
    padding: 2px 0;
    background-color: #a00;
    background-image: linear-gradient(to bottom, rgba(0, 0, 0, 0), rgba(0, 0, 0, 0.15));
    box-shadow: 0 2px 3px 0 rgba(0, 0, 0, 0.5);
    font: 700 12px "Helvetica Neue", Helvetica, Arial, sans-serif;

    pointer-events: auto;

    top: 38px;
    right: -45px;

    transform: rotate(45deg);
  }

  .github-fork-ribbon a[href],
  .github-fork-ribbon a[href]:hover {
    color: #fff;
    background-color: transparent;
    text-decoration: none;
    text-shadow: 0 -1px rgba(0, 0, 0, 0.5);
    text-align: center;

    width: 190px;
    line-height: 18px;

    display: inline-block;
    padding: 2px 0;

    border: 1.5px dotted #fff;
    border-color: rgba(255, 255, 255, 0.6);
  }

  .github-fork-ribbon-wrapper {
    display: block;
    width: 130px;
    height: 130px;
    position: absolute;
    overflow: hidden;
    top: 0; right: 0;
    z-index: 2;
    pointer-events: none;
  }
}
@media screen and (min-width: 1000px) {
  .github-fork-ribbon-wrapper {
    position: fixed;
  }
  /*]]>*/</style>

  <link href="#rfc.toc" rel="Contents"/>
<link href="#rfc.section.1" rel="Chapter" title="1 Introduction"/>
<link href="#rfc.section.1.1" rel="Chapter" title="1.1 Server Certificate Authentication"/>
<link href="#rfc.section.1.2" rel="Chapter" title="1.2 Client Certificate Authentication"/>
<link href="#rfc.section.1.2.1" rel="Chapter" title="1.2.1 HTTP/1.1 using TLS 1.2 and previous"/>
<link href="#rfc.section.1.2.2" rel="Chapter" title="1.2.2 HTTP/1.1 using TLS 1.3"/>
<link href="#rfc.section.1.2.3" rel="Chapter" title="1.2.3 HTTP/2"/>
<link href="#rfc.section.1.3" rel="Chapter" title="1.3 HTTP-Layer Certificate Authentication"/>
<link href="#rfc.section.1.3.1" rel="Chapter" title="1.3.1 Server authentication"/>
<link href="#rfc.section.1.3.2" rel="Chapter" title="1.3.2 Client authentication"/>
<link href="#rfc.section.1.4" rel="Chapter" title="1.4 Terminology"/>
<link href="#rfc.section.2" rel="Chapter" title="2 Determining Availability of Additional Certificates"/>
<link href="#rfc.section.2.1" rel="Chapter" title="2.1 Indicating support for HTTP-layer certificate authentication"/>
<link href="#rfc.section.2.2" rel="Chapter" title="2.2 Client probing for additional certificates"/>
<link href="#rfc.section.2.3" rel="Chapter" title="2.3 Server announcement of additional certificates"/>
<link href="#rfc.section.3" rel="Chapter" title="3 Presenting Certificates at the HTTP/2 Framing Layer"/>
<link href="#rfc.section.3.1" rel="Chapter" title="3.1 The CERTIFICATE_REQUIRED frame"/>
<link href="#rfc.section.3.2" rel="Chapter" title="3.2 The USE_CERTIFICATE Frame"/>
<link href="#rfc.section.3.3" rel="Chapter" title="3.3 The CERTIFICATE_REQUEST Frame"/>
<link href="#rfc.section.3.4" rel="Chapter" title="3.4 The CERTIFICATE frame"/>
<link href="#rfc.section.3.5" rel="Chapter" title="3.5 The CERTIFICATE_PROOF Frame"/>
<link href="#rfc.section.4" rel="Chapter" title="4 Indicating failures during HTTP-Layer Certificate Authentication"/>
<link href="#rfc.section.5" rel="Chapter" title="5 Security Considerations"/>
<link href="#rfc.section.6" rel="Chapter" title="6 IANA Considerations"/>
<link href="#rfc.section.6.1" rel="Chapter" title="6.1 HTTP/2 SETTINGS_HTTP_CERT_AUTH Setting"/>
<link href="#rfc.section.6.2" rel="Chapter" title="6.2 New HTTP/2 Frames"/>
<link href="#rfc.section.6.2.1" rel="Chapter" title="6.2.1 CERTIFICATE_REQUIRED"/>
<link href="#rfc.section.6.2.2" rel="Chapter" title="6.2.2 CERTIFICATE_REQUEST"/>
<link href="#rfc.section.6.2.3" rel="Chapter" title="6.2.3 CERTIFICATE"/>
<link href="#rfc.section.6.2.4" rel="Chapter" title="6.2.4 CERTIFICATE_PROOF"/>
<link href="#rfc.section.6.2.5" rel="Chapter" title="6.2.5 USE_CERTIFICATE"/>
<link href="#rfc.section.6.3" rel="Chapter" title="6.3 New HTTP/2 Error Codes"/>
<link href="#rfc.section.6.3.1" rel="Chapter" title="6.3.1 BAD_CERTIFICATE"/>
<link href="#rfc.section.6.3.2" rel="Chapter" title="6.3.2 UNSUPPORTED_CERTIFICATE"/>
<link href="#rfc.section.6.3.3" rel="Chapter" title="6.3.3 CERTIFICATE_REVOKED"/>
<link href="#rfc.section.6.3.4" rel="Chapter" title="6.3.4 CERTIFICATE_EXPIRED"/>
<link href="#rfc.section.6.3.5" rel="Chapter" title="6.3.5 BAD_SIGNATURE"/>
<link href="#rfc.section.6.3.6" rel="Chapter" title="6.3.6 CERTIFICATE_GENERAL"/>
<link href="#rfc.section.7" rel="Chapter" title="7 Acknowledgements"/>
<link href="#rfc.references" rel="Chapter" title="8 References"/>
<link href="#rfc.references.1" rel="Chapter" title="8.1 Normative References"/>
<link href="#rfc.references.2" rel="Chapter" title="8.2 Informative References"/>
<link href="#rfc.authors" rel="Chapter"/>


  <meta name="generator" content="xml2rfc version 2.5.1 - http://tools.ietf.org/tools/xml2rfc" />
  <link rel="schema.dct" href="http://purl.org/dc/terms/" />

  <meta name="dct.creator" content="Bishop, M. and M. Thomson" />
  <meta name="dct.identifier" content="urn:ietf:id:draft-bishop-httpbis-http2-additional-certs-latest" />
  <meta name="dct.issued" scheme="ISO8601" content="2016-4-13" />
  <meta name="dct.abstract" content="TLS provides fundamental mutual authentication services for HTTP, supporting up to one server certificate and up to one client certificate associated to the session to prove client and server identities as necessary. This draft provides mechanisms for providing additional such certificates at the HTTP layer when these constraints are not sufficient." />
  <meta name="description" content="TLS provides fundamental mutual authentication services for HTTP, supporting up to one server certificate and up to one client certificate associated to the session to prove client and server identities as necessary. This draft provides mechanisms for providing additional such certificates at the HTTP layer when these constraints are not sufficient." />

</head>

<body>

  <table class="header">
    <tbody>
    
    	<tr>
  <td class="left">HTTP</td>
  <td class="right">M. Bishop</td>
</tr>
<tr>
  <td class="left">Internet-Draft</td>
  <td class="right">Microsoft</td>
</tr>
<tr>
  <td class="left">Intended status: Standards Track</td>
  <td class="right">M. Thomson</td>
</tr>
<tr>
  <td class="left">Expires: October 15, 2016</td>
  <td class="right">Mozilla</td>
</tr>
<tr>
  <td class="left"></td>
  <td class="right">April 13, 2016</td>
</tr>

    	
    </tbody>
  </table>

  <p class="title">Secondary Certificate Authentication in HTTP/2<br />
  <span class="filename">draft-bishop-httpbis-http2-additional-certs-latest</span></p>
  
  <h1 id="rfc.abstract">
  <a href="#rfc.abstract">Abstract</a>
</h1>
<p>TLS provides fundamental mutual authentication services for HTTP, supporting up to one server certificate and up to one client certificate associated to the session to prove client and server identities as necessary. This draft provides mechanisms for providing additional such certificates at the HTTP layer when these constraints are not sufficient.</p>
<p>Many HTTP servers host content from several origins. HTTP/2 <a href="#RFC7540">[RFC7540]</a> permits clients to reuse an existing HTTP connection to a server provided that the secondary origin is also in the certificate provided during the TLS <a href="#I-D.ietf-tls-tls13">[I-D.ietf-tls-tls13]</a> handshake.</p>
<p>In many cases, origins will wish to maintain separate certificates for different origins but still desire the benefits of a shared HTTP connection. Similarly, servers may require clients to present authentication, but have different requirements based on the content the client is attempting to access.</p>
<p>This document describes a how such certificates can be provided at the HTTP layer to support both scenarios.</p>
<h1 id="rfc.status">
  <a href="#rfc.status">Status of This Memo</a>
</h1>
<p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p>
<p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF).  Note that other groups may also distribute working documents as Internet-Drafts.  The list of current Internet-Drafts is at http://datatracker.ietf.org/drafts/current/.</p>
<p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time.  It is inappropriate to use Internet-Drafts as reference material or to cite them other than as "work in progress."</p>
<p>This Internet-Draft will expire on October 15, 2016.</p>
<h1 id="rfc.copyrightnotice">
  <a href="#rfc.copyrightnotice">Copyright Notice</a>
</h1>
<p>Copyright (c) 2016 IETF Trust and the persons identified as the document authors.  All rights reserved.</p>
<p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document.  Please review these documents carefully, as they describe your rights and restrictions with respect to this document.  Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p>

  
  <hr class="noprint" />
  <h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1>
  <ul class="toc">

  	<li>1.   <a href="#rfc.section.1">Introduction</a></li>
<ul><li>1.1.   <a href="#rfc.section.1.1">Server Certificate Authentication</a></li>
<li>1.2.   <a href="#rfc.section.1.2">Client Certificate Authentication</a></li>
<ul><li>1.2.1.   <a href="#rfc.section.1.2.1">HTTP/1.1 using TLS 1.2 and previous</a></li>
<li>1.2.2.   <a href="#rfc.section.1.2.2">HTTP/1.1 using TLS 1.3</a></li>
<li>1.2.3.   <a href="#rfc.section.1.2.3">HTTP/2</a></li>
</ul><li>1.3.   <a href="#rfc.section.1.3">HTTP-Layer Certificate Authentication</a></li>
<ul><li>1.3.1.   <a href="#rfc.section.1.3.1">Server authentication</a></li>
<li>1.3.2.   <a href="#rfc.section.1.3.2">Client authentication</a></li>
</ul><li>1.4.   <a href="#rfc.section.1.4">Terminology</a></li>
</ul><li>2.   <a href="#rfc.section.2">Determining Availability of Additional Certificates</a></li>
<ul><li>2.1.   <a href="#rfc.section.2.1">Indicating support for HTTP-layer certificate authentication</a></li>
<li>2.2.   <a href="#rfc.section.2.2">Client probing for additional certificates</a></li>
<li>2.3.   <a href="#rfc.section.2.3">Server announcement of additional certificates</a></li>
</ul><li>3.   <a href="#rfc.section.3">Presenting Certificates at the HTTP/2 Framing Layer</a></li>
<ul><li>3.1.   <a href="#rfc.section.3.1">The CERTIFICATE_REQUIRED frame</a></li>
<li>3.2.   <a href="#rfc.section.3.2">The USE_CERTIFICATE Frame</a></li>
<li>3.3.   <a href="#rfc.section.3.3">The CERTIFICATE_REQUEST Frame</a></li>
<li>3.4.   <a href="#rfc.section.3.4">The CERTIFICATE frame</a></li>
<li>3.5.   <a href="#rfc.section.3.5">The CERTIFICATE_PROOF Frame</a></li>
</ul><li>4.   <a href="#rfc.section.4">Indicating failures during HTTP-Layer Certificate Authentication</a></li>
<li>5.   <a href="#rfc.section.5">Security Considerations</a></li>
<li>6.   <a href="#rfc.section.6">IANA Considerations</a></li>
<ul><li>6.1.   <a href="#rfc.section.6.1">HTTP/2 SETTINGS_HTTP_CERT_AUTH Setting</a></li>
<li>6.2.   <a href="#rfc.section.6.2">New HTTP/2 Frames</a></li>
<ul><li>6.2.1.   <a href="#rfc.section.6.2.1">CERTIFICATE_REQUIRED</a></li>
<li>6.2.2.   <a href="#rfc.section.6.2.2">CERTIFICATE_REQUEST</a></li>
<li>6.2.3.   <a href="#rfc.section.6.2.3">CERTIFICATE</a></li>
<li>6.2.4.   <a href="#rfc.section.6.2.4">CERTIFICATE_PROOF</a></li>
<li>6.2.5.   <a href="#rfc.section.6.2.5">USE_CERTIFICATE</a></li>
</ul><li>6.3.   <a href="#rfc.section.6.3">New HTTP/2 Error Codes</a></li>
<ul><li>6.3.1.   <a href="#rfc.section.6.3.1">BAD_CERTIFICATE</a></li>
<li>6.3.2.   <a href="#rfc.section.6.3.2">UNSUPPORTED_CERTIFICATE</a></li>
<li>6.3.3.   <a href="#rfc.section.6.3.3">CERTIFICATE_REVOKED</a></li>
<li>6.3.4.   <a href="#rfc.section.6.3.4">CERTIFICATE_EXPIRED</a></li>
<li>6.3.5.   <a href="#rfc.section.6.3.5">BAD_SIGNATURE</a></li>
<li>6.3.6.   <a href="#rfc.section.6.3.6">CERTIFICATE_GENERAL</a></li>
</ul></ul><li>7.   <a href="#rfc.section.7">Acknowledgements</a></li>
<li>8.   <a href="#rfc.references">References</a></li>
<ul><li>8.1.   <a href="#rfc.references.1">Normative References</a></li>
<li>8.2.   <a href="#rfc.references.2">Informative References</a></li>
</ul><li><a href="#rfc.authors">Authors' Addresses</a></li>


  </ul>

  <h1 id="rfc.section.1"><a href="#rfc.section.1">1.</a> <a href="#introduction" id="introduction">Introduction</a></h1>
<p id="rfc.section.1.p.1">HTTP clients need to know that the content they receive on a connection comes from the origin that they intended to retrieve in from.  The traditional form of server authentication in HTTP has been in the form of X.509 certificates provided during the TLS <a href="#I-D.ietf-tls-tls13">RFC5246</a> <cite title="NONE">[I-D.ietf-tls-tls13]</cite> handshake.</p>
<p id="rfc.section.1.p.2">Many existing HTTP <a href="#RFC7230">[RFC7230]</a> servers also have authentication requirements for the resources they serve.  Of the bountiful authentication options available for authenticating HTTP requests, client certificates present a unique challenge for resource-specific authentication requirements because of the interaction with the underlying TLS layer.</p>
<p id="rfc.section.1.p.3">TLS 1.2 <a href="#RFC5246">[RFC5246]</a> supports one server and one client certificate on a connection.  These certificates may contain multiple identities, but only one certificate may be provided.</p>
<h1 id="rfc.section.1.1"><a href="#rfc.section.1.1">1.1.</a> <a href="#server-certificate-authentication" id="server-certificate-authentication">Server Certificate Authentication</a></h1>
<p id="rfc.section.1.1.p.1">Section 9.1.1 of <a href="#RFC7540">[RFC7540]</a> describes how connections may be used to make requests from multiple origins as long as the server is authoritative for both. A server is considered authoritative for an origin if DNS resolves the origin to the IP address of the server and (for TLS) if the certificate presented by the server contains the origin in the Subject Alternative Names field.</p>
<p><a href="#I-D.ietf-httpbis-alt-svc">[I-D.ietf-httpbis-alt-svc]</a> enables a step of abstraction from the DNS resolution. If both hosts have provided an Alternative Service at hostnames which resolve to the IP address of the server, they are considered authoritative just as if DNS resolved the origin itself to that address. However, the server&#8217;s one TLS certificate is still required to contain the name of each origin in question.</p>
<p id="rfc.section.1.1.p.3">Servers which host many origins often would prefer to have separate certificates for some sets of origins. This may be for ease of certificate management (the ability to separately revoke or renew them), due to different sources of certificates (a CDN acting on behalf of multiple origins), or other factors which might drive this administrative decision. Clients connecting to such origins cannot currently reuse connections, even if both client and server would prefer to do so.</p>
<h1 id="rfc.section.1.2"><a href="#rfc.section.1.2">1.2.</a> <a href="#client-certificate-authentication" id="client-certificate-authentication">Client Certificate Authentication</a></h1>
<p id="rfc.section.1.2.p.1">For servers that wish to use client certificates to authenticate users, they might request client authentication during or immediately after the TLS handshake. However, if not all users or resources need certificate-based authentication, a request for a certificate has the unfortunate consequence of triggering the client to seek a certificate, possibly requiring user interaction, network traffic, or other time-consuming activities. During this time, the connection is stalled in many implementations. Such a request can result in a poor experience, particularly when sent to a client that does not expect the request.</p>
<p id="rfc.section.1.2.p.2">The TLS 1.3 CertificateRequest can be used by servers to give clients hints about which certificate to offer. Servers that rely on certificate-based authentication might request different certificates for different resources. Such a server cannot use contextual information about the resource to construct an appropriate TLS CertificateRequest message during the initial handshake.</p>
<p id="rfc.section.1.2.p.3">Consequently, client certificates are requested at connection establishment time only in cases where all clients are expected or required to have a single certificate that is used for all resources.  Many other uses for client certificates are reactive, that is, certificates are requested in response to the client making a request.</p>
<h1 id="rfc.section.1.2.1"><a href="#rfc.section.1.2.1">1.2.1.</a> <a href="#http11-using-tls-12-and-previous" id="http11-using-tls-12-and-previous">HTTP/1.1 using TLS 1.2 and previous</a></h1>
<p id="rfc.section.1.2.1.p.1">In HTTP/1.1, a server that relies on client authentication for a subset of users or resources does not request a certificate when the connection is established.  Instead, it only requests a client certificate when a request is made to a resource that requires a certificate.  TLS 1.2 <a href="#RFC5246">[RFC5246]</a> accomodates this by permitting the server to request a new TLS handshake, in which the server will request the client&#8217;s certificate.</p>
<p><a href="#ex-http11">Figure 1</a> shows the server initiating a TLS-layer renegotiation in response to receiving an HTTP/1.1 request to a protected resource.</p>
<div id="rfc.figure.1"/>
<div id="ex-http11"/>
<pre>
Client                                      Server
   -- (HTTP) GET /protected -------------------&gt; *1
   &lt;---------------------- (TLS) HelloRequest -- *2
   -- (TLS) ClientHello -----------------------&gt;
   &lt;------------------ (TLS) ServerHello, ... --
   &lt;---------------- (TLS) CertificateRequest -- *3
   -- (TLS) ..., Certificate ------------------&gt; *4
   -- (TLS) Finished --------------------------&gt;
   &lt;-------------------------- (TLS) Finished --
   &lt;--------------------------- (HTTP) 200 OK -- *5
</pre>
<p class="figure">Figure 1: HTTP/1.1 Reactive Certificate Authentication with TLS 1.2</p>
<p id="rfc.section.1.2.1.p.3">In this example, the server receives a request for a protected resource (at *1 on <a href="#ex-http11">Figure 1</a>).  Upon performing an authorization check, the server determines that the request requires authentication using a client certificate and that no such certificate has been provided.</p>
<p id="rfc.section.1.2.1.p.4">The server initiates TLS renegotiation by sending a TLS HelloRequest (at *2).  The client then initiates a TLS handshake.  Note that some TLS messages are elided from the figure for the sake of brevity.</p>
<p id="rfc.section.1.2.1.p.5">The critical messages for this example are the server requesting a certificate with a TLS CertificateRequest (*3); this request might use information about the request or resource.  The client then provides a certificate and proof of possession of the private key in Certificate and CertificateVerify messages (*4).</p>
<p id="rfc.section.1.2.1.p.6">When the handshake completes, the server performs any authorization checks a second time.  With the client certificate available, it then authorizes the request and provides a response (*5).</p>
<h1 id="rfc.section.1.2.2"><a href="#rfc.section.1.2.2">1.2.2.</a> <a href="#http11-using-tls-13" id="http11-using-tls-13">HTTP/1.1 using TLS 1.3</a></h1>
<p id="rfc.section.1.2.2.p.1">TLS 1.3 <a href="#I-D.ietf-tls-tls13">[I-D.ietf-tls-tls13]</a> introduces a new client authentication mechanism that allows for clients to authenticate after the handshake has been completed.  For the purposes of authenticating an HTTP request, this is functionally equivalent to renegotiation.  <a href="#ex-tls13">Figure 2</a> shows the simpler exchange this enables.</p>
<div id="rfc.figure.2"/>
<div id="ex-tls13"/>
<pre>
Client                                      Server
   -- (HTTP) GET /protected -------------------&gt;
   &lt;---------------- (TLS) CertificateRequest --
   -- (TLS) Certificate, CertificateVerify ----&gt;
   &lt;--------------------------- (HTTP) 200 OK --
</pre>
<p class="figure">Figure 2: HTTP/1.1 Reactive Certificate Authentication with TLS 1.3</p>
<p id="rfc.section.1.2.2.p.2">TLS 1.3 does not support renegotiation, instead supporting direct client authentication.  In contrast to the TLS 1.2 example, in TLS 1.3, a server can simply request a certificate.</p>
<h1 id="rfc.section.1.2.3"><a href="#rfc.section.1.2.3">1.2.3.</a> <a href="#http2" id="http2">HTTP/2</a></h1>
<p id="rfc.section.1.2.3.p.1">An important part of the HTTP/1.1 exchange is that the client is able to easily identify the request that caused the TLS renegotiation.  The client is able to assume that the next unanswered request on the connection is responsible.  The HTTP stack in the client is then able to direct the certificate request to the application or component that initiated that request.  This ensures that the application has the right contextual information for processing the request.</p>
<p id="rfc.section.1.2.3.p.2">In HTTP/2, a client can have multiple outstanding requests.  Without some sort of correlation information, a client is unable to identify which request caused the server to request a certificate.</p>
<p id="rfc.section.1.2.3.p.3">Thus, the minimum necessary mechanism to support reactive certificate authentication in HTTP/2 is an identifier that can be use to correlate an HTTP request with a request for a certificate.</p>
<p><a href="#RFC7540">[RFC7540]</a> prohibits renegotiation after any application data has been sent.  This completely blocks reactive certificate authentication in HTTP/2 using TLS 1.2.  If this restriction were relaxed by an extension or update to HTTP/2, such an identifier could be added to TLS 1.2 by means of an extension to TLS.  Unfortunately, many TLS 1.2 implementations do not permit application data to continue during a renegotiation. This is problematic for a multiplexed protocol like HTTP/2.</p>
<h1 id="rfc.section.1.3"><a href="#rfc.section.1.3">1.3.</a> <a href="#http-layer-certificate-authentication" id="http-layer-certificate-authentication">HTTP-Layer Certificate Authentication</a></h1>
<p id="rfc.section.1.3.p.1">This draft proposes bringing the TLS 1.3 CertificateRequest, Certificate, and CertificateVerify messages into HTTP/2 frames, making client certificate authentication TLS-version-agnostic.</p>
<p id="rfc.section.1.3.p.2">These frames can be used to provide both server and client authentication using certificates. This mechanism can be implemented at the HTTP layer without requiring new TLS stack behavior and without breaking the existing interface between HTTP and applications above it.</p>
<p id="rfc.section.1.3.p.3">This could be done in a naive manner by replicating the messages as HTTP/2 frames on each stream. However, this would create needless redundancy between streams and require frequent expensive signing operations. Instead, this draft lifts the bulky portions of each message into frames on stream zero and permits the on-stream frames to incorporate them by reference as needed.</p>
<p><a href="#discovery">Section 2</a> describes how clients and servers can detect support for this feature in peers and situations which call for it.  <a href="#certs-http2">Section 3</a> describes how certificates can be requested and presented at the HTTP/2 framing layer using several new frame types which parallel the TLS 1.3 message exchange, using the flows described in <a href="#intro-server-auth">Section 1.3.1</a> and <a href="#intro-client-auth">Section 1.3.2</a>. Finally, <a href="#errors">Section 4</a> defines new error types which can be used to notify peers when the exchange has not been successful.</p>
<h1 id="rfc.section.1.3.1"><a href="#rfc.section.1.3.1">1.3.1.</a> <a href="#intro-server-auth" id="intro-server-auth">Server authentication</a></h1>
<p id="rfc.section.1.3.1.p.1">When a client discovers that a server has additional certificates (for example, via an ORIGIN frame; see <a href="#discovery">Section 2</a>) and wishes to examine them, it does this by sending at least one <samp>CERTIFICATE_REQUEST</samp> frame (see <a href="#http-cert-request">Section 3.3</a>) on stream zero.</p>
<p id="rfc.section.1.3.1.p.2">Servers respond to certificate authentication requests by sending one or more <samp>CERTIFICATE</samp> frames (see <a href="#http-certificate">Section 3.4</a>) followed by a <samp>CERTIFICATE_PROOF</samp> frame (see <a href="#http-cert-proof">Section 3.5</a>), on stream zero.</p>
<p id="rfc.section.1.3.1.p.3">The exchange then looks like this:</p>
<div id="rfc.figure.3"/>
<div id="ex-http2-server"/>
<pre>
Client                                      Server
   &lt;----------------------- (stream 0) ORIGIN --
   -- (stream 0) CERTIFICATE_REQUEST ----------&gt;
   &lt;--&lt;--&lt;------------ (stream 0) CERTIFICATE --
   &lt;------------ (stream 0) CERTIFICATE_PROOF --
   -- (streams 1,3) GET /from-new-origin ------&gt;
   &lt;-------------------- (streams 1,3) 200 OK --
   
</pre>
<p class="figure">Figure 3: HTTP/2 Secondary Server Authentication</p>
<p id="rfc.section.1.3.1.p.4">If server-initiated streams are blocked waiting on the client&#8217;s request for additional certificates, the client might also employ <samp>CERTIFICATE_REQUIRED</samp> frames (see <a href="#http-cert-required">Section 3.1</a>) to inform the server of this, but this is not required.</p>
<h1 id="rfc.section.1.3.2"><a href="#rfc.section.1.3.2">1.3.2.</a> <a href="#intro-client-auth" id="intro-client-auth">Client authentication</a></h1>
<p id="rfc.section.1.3.2.p.1">On each stream where certificate authentication is required, the server sends a <samp>CERTIFICATE_REQUIRED</samp> frame, which the client answers with a <samp>USE_CERTIFICATE</samp> frame either indicating the certificate to use, or indicating that no certificate should be used. These frames are simple, referencing information previously sent on stream zero to reduce redundancy.</p>
<p><samp>CERTIFICATE_REQUIRED</samp> frames reference a <samp>CERTIFICATE_REQUEST</samp> on stream zero, analogous to the CertificateRequest message.  <samp>USE_CERTIFICATE</samp> frames reference a sequence of <samp>CERTIFICATE</samp> and <samp>CERTIFICATE_PROOF</samp> frames on stream zero, analogous to the the Certificate and CertificateVerify messages.</p>
<p id="rfc.section.1.3.2.p.3">The exchange then looks like this:</p>
<div id="rfc.figure.4"/>
<div id="ex-http2-client"/>
<pre>
Client                                      Server
   -- (streams 1,3) GET /protected ------------&gt;
   &lt;---------- (stream 0) CERTIFICATE_REQUEST --
   &lt;------ (streams 1,3) CERTIFICATE_REQUIRED --
   -- (stream 0) CERTIFICATE ------------&gt;--&gt;--&gt;
   -- (stream 0) CERTIFICATE_PROOF ------------&gt;
   -- (streams 1,3) USE_CERTIFICATE -----------&gt;
   &lt;-------------------- (streams 1,3) 200 OK --
   
</pre>
<p class="figure">Figure 4: HTTP/2 Reactive Certificate Authentication</p>
<p id="rfc.section.1.3.2.p.4">To avoid the extra round-trip per stream required for a challenge and response, the <samp>AUTOMATIC_USE</samp> flag enables a certificate to be automatically used by the recipient on subsequent requests without sending a <samp>CERTIFICATE_REQUIRED</samp> exchange.  This flag is always set by servers, but optional for clients.</p>
<h1 id="rfc.section.1.4"><a href="#rfc.section.1.4">1.4.</a> <a href="#terminology" id="terminology">Terminology</a></h1>
<p id="rfc.section.1.4.p.1">RFC 2119 <a href="#RFC2119">[RFC2119]</a> defines the terms &#8220;MUST&#8221;, &#8220;MUST NOT&#8221;, &#8220;SHOULD&#8221; and &#8220;MAY&#8221;.</p>
<h1 id="rfc.section.2"><a href="#rfc.section.2">2.</a> <a href="#discovery" id="discovery">Determining Availability of Additional Certificates</a></h1>
<h1 id="rfc.section.2.1"><a href="#rfc.section.2.1">2.1.</a> <a href="#setting" id="setting">Indicating support for HTTP-layer certificate authentication</a></h1>
<p id="rfc.section.2.1.p.1">Clients and servers that will accept requests for HTTP-layer certificate authentication indicate this using the HTTP/2 <samp>SETTINGS_HTTP_CERT_AUTH</samp> (0xSETTING-TBD) setting.</p>
<p id="rfc.section.2.1.p.2">The initial value for the <samp>SETTINGS_HTTP_CERT_AUTH</samp> setting is 0, indicating that the neither peer supports HTTP-layer authentication. A client sets the <samp>SETTINGS_HTTP_CERT_AUTH</samp> setting to a value of 1 to indicate support for HTTP-layer certificate authentication as defined in this document. A server sets the <samp>SETTINGS_HTTP_CERT_AUTH</samp> setting to a value of 1 to indicate the ability to provide additional certificates as defined in this document. Any value other than 0 or 1 MUST be treated as a connection error (Section 5.4.1 of <a href="#RFC7540">[RFC7540]</a>) of type <samp>PROTOCOL_ERROR</samp>.</p>
<p id="rfc.section.2.1.p.3">Note that a client or server MAY initiate such requests without being willing to receive them; implementations which have announced support MUST properly handle receipt of frames defined in this document regardless of their peer&#8217;s announced setting.</p>
<h1 id="rfc.section.2.2"><a href="#rfc.section.2.2">2.2.</a> <a href="#discovery-client" id="discovery-client">Client probing for additional certificates</a></h1>
<p id="rfc.section.2.2.p.1">As defined in <a href="#RFC7540">[RFC7540]</a>, when a client finds that a https:// origin (or Alternative Service <a href="#I-D.ietf-httpbis-alt-svc">[I-D.ietf-httpbis-alt-svc]</a>) to which it needs to make a request has the same IP address as a server to which it is already connected, it MAY check whether the TLS certificate provided contains the new origin as well, and if so, reuse the connection.</p>
<p id="rfc.section.2.2.p.2">If the TLS certificate does not contain the new origin, but the server has advertised support for HTTP-layer certificates (see <a href="#setting">Section 2.1</a>, the client MAY also send a <samp>CERTIFICATE_REQUEST</samp> frame <a href="#http-cert-request">Section 3.3</a> on stream zero requesting a certificate for the desired origin. A client MAY send multiple concurrent <samp>CERTIFICATE_REQUEST</samp> frames for different origins. The server responds to each with a series of <samp>CERTIFICATE</samp> frames containing the relevant certificate chain, if it possesses such a certificate. If not, the server responds with an empty <samp>CERTIFICATE</samp> frame.</p>
<p id="rfc.section.2.2.p.3">In this case, or if the server has not advertised support for HTTP-layer certificates, the client MUST NOT send any requests for resources in that origin on the current connection.</p>
<h1 id="rfc.section.2.3"><a href="#rfc.section.2.3">2.3.</a> <a href="#server-announcement-of-additional-certificates" id="server-announcement-of-additional-certificates">Server announcement of additional certificates</a></h1>
<p id="rfc.section.2.3.p.1">Because the approach in <a href="#discovery-client">Section 2.2</a> requires an extra round-trip to the server before the client can determine whether a new TCP connection will be required, some origins will wish to proactively alert clients to certificates they possess. Servers might also wish to proactively prove their authority for an origin for which it intends to deliver pushed resources.</p>
<p id="rfc.section.2.3.p.2">The server MAY send an <samp>ORIGIN</samp> frame including origins which are not in its TLS certificate. This represents an explicit claim by the server to possess the appropriate certificate &#8211; a claim the client MUST verify using the procedures in <a href="#discovery-client">Section 2.2</a> before relying on the server&#8217;s authority for the claimed origin.</p>
<p id="rfc.section.2.3.p.3">The server MAY push resources from an origin for which it is authoritative but for which the client has not yet received the certificate. In this case, the client MUST verify the server&#8217;s possession of an appropriate certificate a <samp>CERTIFICATE_REQUEST</samp> on stream zero. The client SHOULD also send a <samp>CERTIFICATE_REQUIRED</samp> frame on the pushed stream to inform the server that progress is blocked until the request is satisfied. The client MUST NOT use the pushed resource until an appropriate certificate has been received and validated.</p>
<h1 id="rfc.section.3"><a href="#rfc.section.3">3.</a> <a href="#certs-http2" id="certs-http2">Presenting Certificates at the HTTP/2 Framing Layer</a></h1>
<p id="rfc.section.3.p.1">When either peer wishes to obtain a certificate before making or completing a request, it does this by sending at least one <samp>CERTIFICATE_REQUEST</samp> frame (see <a href="#http-cert-request">Section 3.3</a>) on stream zero and sending a <samp>CERTIFICATE_REQUIRED</samp> frame (see <a href="#http-cert-required">Section 3.1</a>) on any affected streams which are not in the &#8220;idle&#8221; state.  The <samp>CERTIFICATE_REQUEST</samp> and <samp>CERTIFICATE_REQUIRED</samp> frames are correlated by their <samp>Request-ID</samp> field. Subsequent <samp>CERTIFICATE_REQUIRED</samp> frames with the same Request-ID MAY be sent on other streams where the sender is expecting a certificate with the same parameters.</p>
<p id="rfc.section.3.p.2">The recipient responds to these requests by sending one or more <samp>CERTIFICATE</samp> frames (see <a href="#http-certificate">Section 3.4</a>), followed by a <samp>CERTIFICATE_PROOF</samp> frame (see <a href="#http-cert-proof">Section 3.5</a>), on stream zero containing the <samp>Request-ID</samp> to which they are responding. The <samp>USE_CERTIFICATE</samp> (see <a href="#http-use-certificate">Section 3.2</a>) frame is sent on-stream to notify the requestor that the stream is ready to be processed.</p>
<p id="rfc.section.3.p.3">To reduce round-trips, the holder of a certificate MAY set the <samp>AUTOMATIC_USE</samp> flag on a <samp>CERTIFICATE_PROOF</samp> frame, indicating that the peer SHOULD automatically apply the supplied certificate to any future streams matching that request, rather than sending a <samp>CERTIFICATE_REQUIRED</samp> frame. Servers MUST set the <samp>AUTOMATIC_USE</samp> flag on all <samp>CERTIFICATE_PROOF</samp> frames.</p>
<h1 id="rfc.section.3.1"><a href="#rfc.section.3.1">3.1.</a> <a href="#http-cert-required" id="http-cert-required">The CERTIFICATE_REQUIRED frame</a></h1>
<p id="rfc.section.3.1.p.1">The <samp>CERTIFICATE_REQUIRED</samp> frame (0xFRAME-TBD2) is sent to indicate that processing of an HTTP request is blocked pending certificate authentication. The frame includes a request identifier which can be used to correlate the stream with a previous <samp>CERTIFICATE_REQUEST</samp> frame sent on stream zero. The <samp>CERTIFICATE_REQUEST</samp> describes the certificate the sender requires before continuing to process the stream in question.</p>
<p id="rfc.section.3.1.p.2">The <samp>CERTIFICATE_REQUIRED</samp> frame contains 1 octet, which is the authentication request identifier. A peer that receives a <samp>CERTIFICATE_REQUIRED</samp> of any other length MUST treat this as a stream error of type <samp>PROTOCOL_ERROR</samp>. Frames with identical request identifiers refer to the same <samp>CERTIFICATE_REQUEST</samp>.</p>
<p id="rfc.section.3.1.p.3">A server MAY send multiple concurrent <samp>CERTIFICATE_REQUIRED</samp> frames on the same stream. If a server requires that a client provide multiple certificates before authorizing a single request, it MUST send a <samp>CERTIFICATE_REQUIRED</samp> frame with a different request identifier and a corresponding <samp>CERTIFICATE_REQUEST</samp> frame describing each required certificate. Clients MUST NOT send multiple <samp>CERTIFICATE_REQUIRED</samp> frames on the same server-initiated stream.</p>
<p id="rfc.section.3.1.p.4">The <samp>CERTIFICATE_REQUIRED</samp> frame MUST NOT be sent on stream zero, a stream initiated by the sender, or a stream in the idle state. The <samp>CERTIFICATE_REQUIRED</samp> frame SHOULD NOT be sent to a peer which has not advertised support for HTTP-layer certificate authentication.</p>
<p id="rfc.section.3.1.p.5">A client that receives a <samp>CERTIFICATE_REQUIRED</samp> frame on a stream which is not in a valid state SHOULD treat this as a stream error of type <samp>PROTOCOL_ERROR</samp>.</p>
<h1 id="rfc.section.3.2"><a href="#rfc.section.3.2">3.2.</a> <a href="#http-use-certificate" id="http-use-certificate">The USE_CERTIFICATE Frame</a></h1>
<p id="rfc.section.3.2.p.1">The <samp>USE_CERTIFICATE</samp> frame (0xFRAME-TBD5) is sent in response to a <samp>CERTIFICATE_REQUIRED</samp> frame to indicate that the requested certificate has been provided (or will not be).</p>
<p id="rfc.section.3.2.p.2">A <samp>USE_CERTIFICATE</samp> frame with no payload expresses the sender&#8217;s refusal to use the associated certificate (if any) with this stream. If the certificate request was originally issued for a different stream, recipients MAY create a new <samp>CERTIFICATE_REQUEST</samp> and permit the sender to offer a different certificate. Alternatively, recipients MAY process the affected streams as unauthenticated, likely returning an authentication-related error at the HTTP level (e.g. 403) for servers or discarding a pushed resource for clients.</p>
<p id="rfc.section.3.2.p.3">Otherwise, the <samp>USE_CERTIFICATE</samp> frame contains the <samp>Request-ID</samp> of the now-completed certificate request. This MUST be an ID previously issued by the recipient, and for which a matching certificate has previously been presented along with a supporting certificate chain in one or more <samp>CERTIFICATE</samp> frames, and for which proof of possession has been presented in a <samp>CERTIFICATE_PROOF</samp> frame. Recipients of a <samp>USE_CERTIFICATE</samp> of any other length MUST treat this as a stream error of type <samp>PROTOCOL_ERROR</samp>. Frames with identical request identifiers refer to the same certificate chain.</p>
<p id="rfc.section.3.2.p.4">The <samp>USE_CERTIFICATE</samp> frame MUST NOT be sent on stream zero, a stream initiated by the sender, or a stream on which a <samp>CERTIFICATE_REQUIRED</samp> frame has not been received. Receipt of a <samp>USE_CERTIFICATE</samp> frame in these circmustances SHOULD be treated as a stream error of type <samp>PROTOCOL_ERROR</samp>.</p>
<h1 id="rfc.section.3.3"><a href="#rfc.section.3.3">3.3.</a> <a href="#http-cert-request" id="http-cert-request">The CERTIFICATE_REQUEST Frame</a></h1>
<p id="rfc.section.3.3.p.1">TLS 1.3 defines the <samp>CertificateRequest</samp> message, which prompts the client to provide a certificate which conforms to certain properties specified by the server.  This draft defines the <samp>CERTIFICATE_REQUEST</samp> frame (0xFRAME-TBD1), which contains the same contents as a TLS 1.3 <samp>CertificateRequest</samp> message, but can be sent over any TLS version.</p>
<p id="rfc.section.3.3.p.2">The <samp>CERTIFICATE_REQUEST</samp> frame SHOULD NOT be sent to a peer which has not advertised support for HTTP-layer certificate authentication.</p>
<p id="rfc.section.3.3.p.3">The <samp>CERTIFICATE_REQUEST</samp> frame MUST be sent on stream zero.  A <samp>CERTIFICATE_REQUEST</samp> frame received on any other stream MUST be rejected with a stream error of type <samp>PROTOCOL_ERROR</samp>.</p>
<div id="rfc.figure.5"/>
<div id="fig-cert-request"/>
<pre>
  0                   1                   2                   3
  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 +-------------------------------+-------------------------------+
 | Request-ID (8)|     Algorithm-Count (16)      | Algorithms  ...
 +---------------------------------------------------------------+
 |       CA-Count (16)           |  Certificate-Authorities(?) ...
 +---------------------------------------------------------------+
 |   Cert-Extension-Count (16)   |       Cert-Extensions(?)    ...
 +---------------------------------------------------------------+
</pre>
<p class="figure">Figure 5: CERTIFICATE_REQUEST frame payload</p>
<p id="rfc.section.3.3.p.4">The frame contains the following fields:</p>
<p/>

<dl>
  <dt>Request-ID:</dt>
  <dd style="margin-left: 8"><samp>Request-ID</samp> is an 8-bit opaque identifier used to correlate subsequent certificate-related frames with this request.  The identifier MUST be unique in the session for the sender.</dd>
  <dt>Algorithm-Count and Algorithms:</dt>
  <dd style="margin-left: 8">A list of the hash/signature algorithm pairs that the sender is able to verify, listed in descending order of preference. Any certificates provided by the recipient MUST be signed using a hash/signature algorithm pair found in <samp>Algorithms</samp>. Each algorithm pair is encoded as a <samp>SignatureAndHashAlgorithm</samp> (see <a href="#I-D.ietf-tls-tls13">[I-D.ietf-tls-tls13]</a> section 6.3.2.1), and the number of such structures is given by the 16-bit <samp>Algorithm-Count</samp> field, which MUST NOT be zero.</dd>
  <dt>CA-Count and Certificate-Authorities:</dt>
  <dd style="margin-left: 8"><samp>Certificate-Authorities</samp> is a series of distinguished names of acceptable certificate authorities, represented in DER-encoded <a href="#X690">[X690]</a> format.  These distinguished names may specify a desired distinguished name for a root CA or for a subordinate CA; thus, this message can be used to describe known roots as well as a desired authorization space. The number of such structures is given by the 16-bit <samp>CA-Count</samp> field, which MAY be zero. If the <samp>CA-Count</samp> field is zero, then the recipient MAY send any certificate that meets the rest of the selection criteria in the <samp>CERTIFICATE_REQUEST</samp>, unless there is some external arrangement to the contrary.</dd>
  <dt>Cert-Extension-Count and Cert-Extensions:</dt>
  <dd style="margin-left: 8">A list of certificate extension OIDs <a href="#RFC5280">[RFC5280]</a> with their allowed values, represented in a series of <samp>CertificateExtension</samp> structures (see <a href="#I-D.ietf-tls-tls13">[I-D.ietf-tls-tls13]</a> section 6.3.5). The list of OIDs MUST be used in certificate selection as described in <a href="#I-D.ietf-tls-tls13">[I-D.ietf-tls-tls13]</a>. The number of Cert-Extension structures is given by the 16-bit <samp>Cert-Extension-Count</samp> field, which MAY be zero.</dd>
</dl>
<p id="rfc.section.3.3.p.6">Servers MUST be able to recognize the &#8220;subjectAltName&#8221; extension (<a href="#RFC2459">[RFC2459]</a> section 4.2.1.7) at a minimum. Clients MUST always specify the desired origin using this extension, though other extensions MAY also be included.</p>
<p id="rfc.section.3.3.p.7">Some certificate extension OIDs allow multiple values (e.g. Extended Key Usage). If the sender has included a non-empty Cert-Extensions list, the certificate MUST contain all of the specified extension OIDs that the recipient recognizes. For each extension OID recognized by the recipient, all of the specified values MUST be present in the certificate (but the certificate MAY have other values as well).  However, the recipient MUST ignore and skip any unrecognized certificate extension OIDs.</p>
<p id="rfc.section.3.3.p.8">PKIX RFCs define a variety of certificate extension OIDs and their corresponding value types. Depending on the type, matching certificate extension values are not necessarily bitwise-equal. It is expected that implementations will rely on their PKI libraries to perform certificate selection using these certificate extension OIDs.</p>
<h1 id="rfc.section.3.4"><a href="#rfc.section.3.4">3.4.</a> <a href="#http-certificate" id="http-certificate">The CERTIFICATE frame</a></h1>
<p id="rfc.section.3.4.p.1">A certificate chain is transferred as a series of <samp>CERTIFICATE</samp> frames (0xFRAME-TBD3) with the same Request-ID, each containing a single certificate in the chain. The end certificate of the chain can be used as authentication for previous or subsequent requests.</p>
<p id="rfc.section.3.4.p.2">The <samp>CERTIFICATE</samp> frame defines no flags.</p>
<p id="rfc.section.3.4.p.3">While unlikely, it is possible that an exceptionally large certificate might be too large to fit in a single HTTP/2 frame (see <a href="#RFC7540">[RFC7540]</a> section 4.2). Senders unable to transfer a requested certificate due to the recipient&#8217;s <samp>SETTINGS_MAX_FRAME_SIZE</samp> value SHOULD terminate affected streams with <samp>CERTIFICATE_TOO_LARGE</samp>.</p>
<p id="rfc.section.3.4.p.4">The <samp>CERTIFICATE</samp> frame MUST be sent on stream zero.  A <samp>CERTIFICATE</samp> frame received on any other stream MUST be rejected with a stream error of type <samp>PROTOCOL_ERROR</samp>.</p>
<div id="rfc.figure.6"/>
<div id="fig-cert-frame"/>
<pre>
  0                   1                   2                   3
  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 +-------------------------------+-------------------------------+
 | Request-ID (8)|                Certificate (*)              ...
 +---------------------------------------------------------------+
 
</pre>
<p class="figure">Figure 6: CERTIFICATE frame payload</p>
<p id="rfc.section.3.4.p.5">The fields defined by the <samp>CERTIFICATE</samp> frame are:</p>
<p/>

<dl>
  <dt>Request-ID:</dt>
  <dd style="margin-left: 8">The ID of the <samp>CERTIFICATE_REQUEST</samp> to which this frame responds.</dd>
  <dt>Certificate:</dt>
  <dd style="margin-left: 8">An X.509v3 <a href="#RFC5280">[RFC5280]</a> certificate in the sender&#8217;s certificate chain.</dd>
</dl>
<p id="rfc.section.3.4.p.7">The first or only <samp>CERTIFICATE</samp> frame with a given Request-ID MUST contain the sender&#8217;s certificate. Each subsequent certificate SHOULD directly certify the certificate immediately preceding it. A certificate which specifies a trust anchor MAY be omitted, provided that the recipient is known to already possess the relevant certificate. (For example, because it was included in a <samp>CERTIFICATE_REQUEST</samp>&#8217;s Certificate-Authorities list.)</p>
<p id="rfc.section.3.4.p.8">The <samp>Request-ID</samp> field MUST contain the same value as the corresponding <samp>CERTIFICATE_REQUEST</samp> frame, and the provided certificate chain MUST conform to the requirements expressed in the <samp>CERTIFICATE_REQUEST</samp> to the best of the sender&#8217;s ability. Specifically:</p>
<p/>

<ul>
  <li>If the <samp>CERTIFICATE_REQUEST</samp> contained a non-empty <samp>Certificate-Authorities</samp> element, one of the certificates in the chain SHOULD be signed by one of the listed CAs.</li>
  <li>If the <samp>CERTIFICATE_REQUEST</samp> contained a non-empty <samp>Cert-Extensions</samp> element, the first certificate MUST match with regard to the extension OIDs recognized by the sender.</li>
  <li>Each certificate that is not self-signed MUST be signed using a hash/signature algorithm listed in the <samp>Algorithms</samp> element.</li>
</ul>
<p id="rfc.section.3.4.p.10">If these requirements are not satisfied, the recipient MAY at its discretion either process the request without considering the certificate chain, or respond with a stream error <a href="#RFC7540">[RFC7540]</a> on any stream where the certificate is used. <a href="#errors">Section 4</a> defines certificate-related error codes which might be applicable.</p>
<p id="rfc.section.3.4.p.11">The recipient of a <samp>CERTIFICATE_REQUEST</samp> cannot respond with different certificates for use on different streams. A client that has already sent and proven a certificate, but does not wish to use it on a particular stream SHOULD send an empty <samp>USE_CERTIFICATE</samp> frame, refusing to use that certificate on that stream. A server MUST NOT send certificates for origins which it is not prepared to service on the current connection.</p>
<h1 id="rfc.section.3.5"><a href="#rfc.section.3.5">3.5.</a> <a href="#http-cert-proof" id="http-cert-proof">The CERTIFICATE_PROOF Frame</a></h1>
<p id="rfc.section.3.5.p.1">The <samp>CERTIFICATE_PROOF</samp> frame proves possession of the private key corresponding to an end certificate previously shown in a <samp>CERTIFICATE</samp> frame.</p>
<p id="rfc.section.3.5.p.2">The <samp>CERTIFICATE_PROOF</samp> frame defines one flag:</p>
<p/>

<dl>
  <dt>AUTOMATIC_USE (0x01):</dt>
  <dd style="margin-left: 8">Indicates that the certificate can be used automatically on future requests.</dd>
</dl>
<div id="rfc.figure.7"/>
<div id="fig-proof-frame"/>
<pre>
  0                   1                   2                   3
  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 +-------------------------------+-------------------------------+
 | Request-ID (8)|         Algorithm (16)        | Signature(*)...
 +---------------------------------------------------------------+
 
</pre>
<p class="figure">Figure 7: CERTIFICATE_PROOF frame payload</p>
<p id="rfc.section.3.5.p.4">The <samp>CERTIFICATE_PROOF</samp> frame (0xFRAME-TBD4) contains an <samp>Algorithm</samp> field (a <samp>SignatureAndHashAlgorithm</samp>, from <a href="#I-D.ietf-tls-tls13">[I-D.ietf-tls-tls13]</a> section 6.3.2.1), describing the hash/signature algorithm pair being used. The signature is performed as described in <a href="#I-D.ietf-tls-tls13">[I-D.ietf-tls-tls13]</a>, with the following values being used:</p>
<p/>

<ul>
  <li>The context string for the signature is &#8220;HTTP/2 CERTIFICATE_PROOF&#8221;</li>
  <li>The &#8220;specified content&#8221; is an <a href="#RFC5705">[RFC5705]</a> exported value, with the following parameters: <ul><li>Disambiguating label string: &#8220;EXPORTER HTTP/2 CERTIFICATE_PROOF&#8221;</li><li>Length:  64 bytes</li></ul></li>
</ul>
<p id="rfc.section.3.5.p.6">Because the exported value can be independently calculated by both sides of the TLS connection, the value to be signed is not sent on the wire at any time.  The same signed value is used for all <samp>CERTIFICATE_PROOF</samp> frames in a single HTTP/2 connection.</p>
<p id="rfc.section.3.5.p.7">A <samp>CERTIFICATE_PROOF</samp> frame MUST be sent only after all <samp>CERTIFICATE</samp> frames with the same Request-ID have been sent, and MUST correspond to the first certificate presented in the first <samp>CERTIFICATE</samp> frame with that Request-ID. Receipt of multiple <samp>CERTIFICATE_PROOF</samp> frames for the same Request-ID, receipt of a <samp>CERTIFICATE_PROOF</samp> frame without a corresponding <samp>CERTIFICATE</samp> frame, or receipt of a <samp>CERTIFICATE</samp> frame after a corresponding <samp>CERTIFICATE_PROOF</samp> MUST be treated as a session error of type <samp>PROTOCOL_ERROR</samp>.</p>
<p id="rfc.section.3.5.p.8">If the <samp>AUTOMATIC_USE</samp> flag is set, the recipient MAY omit sending <samp>CERTIFICATE_REQUIRED</samp> frames on future streams associated with this certificate request and use the referenced certificate for authentication without further notice to the holder. This behavior is optional, and receipt of a <samp>CERTIFICATE_REQUIRED</samp> frame does not imply that previously-presented certificates were unacceptable to the server.  Servers MUST set the <samp>AUTOMATIC_USE</samp> flag when sending a <samp>CERTIFICATE_PROOF</samp> frame.</p>
<h1 id="rfc.section.4"><a href="#rfc.section.4">4.</a> <a href="#errors" id="errors">Indicating failures during HTTP-Layer Certificate Authentication</a></h1>
<p id="rfc.section.4.p.1">Because this draft permits client certificates to be exchanged at the HTTP framing layer instead of the TLS layer, several certificate-related errors which are defined at the TLS layer might now occur at the HTTP framing layer. In this section, those errors are restated and added to the HTTP/2 error code registry.</p>
<p/>

<dl>
  <dt>BAD_CERTIFICATE (0xERROR-TBD1):</dt>
  <dd style="margin-left: 8">A certificate was corrupt, contained signatures that did not verify correctly, etc.</dd>
  <dt>UNSUPPORTED_CERTIFICATE (0xERROR-TBD2):</dt>
  <dd style="margin-left: 8">A certificate was of an unsupported type or did not contain required extensions</dd>
  <dt>CERTIFICATE_REVOKED (0xERROR-TBD3):</dt>
  <dd style="margin-left: 8">A certificate was revoked by its signer</dd>
  <dt>CERTIFICATE_EXPIRED (0xERROR-TBD4):</dt>
  <dd style="margin-left: 8">A certificate has expired or is not currently valid</dd>
  <dt>BAD_SIGNATURE (0xERROR-TBD5):</dt>
  <dd style="margin-left: 8">The digital signature provided did not match</dd>
  <dt>CERTIFICATE_TOO_LARGE (0xERROR-TBD6):</dt>
  <dd style="margin-left: 8">The certificate cannot be transferred due to the recipient&#8217;s <samp>SETTINGS_MAX_FRAME_SIZE</samp></dd>
  <dt>CERTIFICATE_GENERAL (0xERROR-TBD7):</dt>
  <dd style="margin-left: 8">Any other certificate-related error</dd>
</dl>
<p id="rfc.section.4.p.3">As described in <a href="#RFC7540">[RFC7540]</a>, implementations MAY choose to treat a stream error as a connection error at any time. Of particular note, a stream error cannot occur on stream 0, which means that implementations cannot send non-session errors in response to <samp>CERTIFICATE_REQUEST</samp>, <samp>CERTIFICATE</samp>, and <samp>CERTIFICATE_PROOF</samp> frames. Implementations which do not wish to terminate the connection MAY either send relevant errors on any stream which references the failing certificate in question or process the requests as unauthenticated and provide error information at the HTTP semantic layer.</p>
<h1 id="rfc.section.5"><a href="#rfc.section.5">5.</a> <a href="#security" id="security">Security Considerations</a></h1>
<p id="rfc.section.5.p.1">This mechanism defines an alternate way to obtain server and client certificates other than the TLS handshake. While the signature of exporter values is expected to be equally secure, it is important to recognize that a vulnerability in this code path is equal to a vulnerability in the TLS handshake.</p>
<p id="rfc.section.5.p.2">This draft defines a mechanism which could be used to probe servers for origins they support, but opens no new attack versus making repeat TLS connections with different SNI values. Servers SHOULD impose similar denial-of-service mitigations (e.g. request rate limits) to <samp>CERTIFICATE_REQUEST</samp> frames as to new TLS connections.</p>
<p id="rfc.section.5.p.3">While the <samp>CERTIFICATE_REQUEST</samp> frame permits the sender to enumerate the acceptable Certificate Authorities for the requested certificate, it might not be prudent (either for security or data consumption) to include the full list of trusted Certificate Authorities in every request. Senders, particularly clients, are advised to send an empty <samp>Certificate-Authorities</samp> element unless they are expecting a certificate to be signed by a particular CA or small set of CAs.</p>
<p id="rfc.section.5.p.4">Failure to provide a certificate on a stream after receiving <samp>CERTIFICATE_REQUIRED</samp> blocks processing, and SHOULD be subject to standard timeouts used to guard against unresponsive peers.</p>
<p id="rfc.section.5.p.5">In order to protect the privacy of the connection against triple-handshake attacks, this feature of HTTP/2 MUST be used only over TLS 1.3 or greater, or over TLS 1.2 in combination with the Extended Master Secret extension defined in <a href="#RFC7627">[RFC7627]</a>. Because this feature is intended to operate with equivalent security to the TLS connection, hash and signature algorithms not permitted by the version of TLS in use MUST NOT be used. Additionally, the following algorithms MUST NOT be used, even if permitted by the underlying TLS version:</p>
<p/>

<ul>
  <li>MD5</li>
  <li>SHA1</li>
  <li>SHA224</li>
  <li>DSA</li>
  <li>ECDSA with curves on prime fields that are less than 240 bits wide</li>
  <li>RSA with a prime modulus less than 2048 bits</li>
</ul>
<p id="rfc.section.5.p.7">Client implementations need to carefully consider the impact of setting the <samp>AUTOMATIC_USE</samp> flag. This flag is a performance optimization, permitting the client to avoid a round-trip on each request where the server checks for certificate authentication. However, once this flag has been sent, the client has zero knowledge about whether the server will use the referenced cert for any future request, or even for an existing request which has not yet completed. Clients MUST NOT set this flag on any certificate which is not appropriate for currently-in-flight requests, and MUST NOT make any future requests on the same connection which they are not willing to have associated with the provided certificate.</p>
<p id="rfc.section.5.p.8">Implementations need to be aware of the potential for confusion about the state of a connection. The presence or absence of a validated certificate can change during the processing of a request, potentially multiple times, as <samp>USE_CERTIFICATE</samp> frames are received. A server that uses certificate authentication needs to be prepared to reevaluate the authorization state of a request as the set of certificates changes.</p>
<h1 id="rfc.section.6"><a href="#rfc.section.6">6.</a> <a href="#iana" id="iana">IANA Considerations</a></h1>
<p id="rfc.section.6.p.1">The HTTP/2 <samp>SETTINGS_HTTP_CERT_AUTH</samp> setting is registered in <a href="#iana-setting">Section 6.1</a>.  Five frame types are registered in <a href="#iana-frame">Section 6.2</a>.  Six error codes are registered in <a href="#iana-errors">Section 6.3</a>.</p>
<h1 id="rfc.section.6.1"><a href="#rfc.section.6.1">6.1.</a> <a href="#iana-setting" id="iana-setting">HTTP/2 SETTINGS_HTTP_CERT_AUTH Setting</a></h1>
<p id="rfc.section.6.1.p.1">The SETTINGS_HTTP_CERT_AUTH setting is registered in the &#8220;HTTP/2 Settings&#8221; registry established in <a href="#RFC7540">[RFC7540]</a>.</p>
<p/>

<dl>
  <dt>Name:</dt>
  <dd style="margin-left: 8">SETTINGS_HTTP_CERT_AUTH</dd>
  <dt>Code:</dt>
  <dd style="margin-left: 8">0xSETTING-TBD</dd>
  <dt>Initial Value:</dt>
  <dd style="margin-left: 8">0</dd>
  <dt>Specification:</dt>
  <dd style="margin-left: 8">This document.</dd>
</dl>
<h1 id="rfc.section.6.2"><a href="#rfc.section.6.2">6.2.</a> <a href="#iana-frame" id="iana-frame">New HTTP/2 Frames</a></h1>
<p id="rfc.section.6.2.p.1">Four new frame types are registered in the &#8220;HTTP/2 Frame Types&#8221; registry established in <a href="#RFC7540">[RFC7540]</a>.</p>
<h1 id="rfc.section.6.2.1"><a href="#rfc.section.6.2.1">6.2.1.</a> <a href="#certificaterequired" id="certificaterequired">CERTIFICATE_REQUIRED</a></h1>
<p/>

<dl>
  <dt>Frame Type:</dt>
  <dd style="margin-left: 8">CERTIFICATE_REQUIRED</dd>
  <dt>Code:</dt>
  <dd style="margin-left: 8">0xFRAME-TBD1</dd>
  <dt>Specification:</dt>
  <dd style="margin-left: 8">This document.</dd>
</dl>
<h1 id="rfc.section.6.2.2"><a href="#rfc.section.6.2.2">6.2.2.</a> <a href="#certificaterequest" id="certificaterequest">CERTIFICATE_REQUEST</a></h1>
<p/>

<dl>
  <dt>Frame Type:</dt>
  <dd style="margin-left: 8">CERTIFICATE_REQUEST</dd>
  <dt>Code:</dt>
  <dd style="margin-left: 8">0xFRAME-TBD2</dd>
  <dt>Specification:</dt>
  <dd style="margin-left: 8">This document.</dd>
</dl>
<h1 id="rfc.section.6.2.3"><a href="#rfc.section.6.2.3">6.2.3.</a> <a href="#certificate" id="certificate">CERTIFICATE</a></h1>
<p/>

<dl>
  <dt>Frame Type:</dt>
  <dd style="margin-left: 8">CERTIFICATE</dd>
  <dt>Code:</dt>
  <dd style="margin-left: 8">0xFRAME-TBD3</dd>
  <dt>Specification:</dt>
  <dd style="margin-left: 8">This document.</dd>
</dl>
<h1 id="rfc.section.6.2.4"><a href="#rfc.section.6.2.4">6.2.4.</a> <a href="#certificateproof" id="certificateproof">CERTIFICATE_PROOF</a></h1>
<p/>

<dl>
  <dt>Frame Type:</dt>
  <dd style="margin-left: 8">CERTIFICATE_PROOF</dd>
  <dt>Code:</dt>
  <dd style="margin-left: 8">0xFRAME-TBD4</dd>
  <dt>Specification:</dt>
  <dd style="margin-left: 8">This document.</dd>
</dl>
<h1 id="rfc.section.6.2.5"><a href="#rfc.section.6.2.5">6.2.5.</a> <a href="#usecertificate" id="usecertificate">USE_CERTIFICATE</a></h1>
<p/>

<dl>
  <dt>Frame Type:</dt>
  <dd style="margin-left: 8">USE_CERTIFICATE</dd>
  <dt>Code:</dt>
  <dd style="margin-left: 8">0xFRAME-TBD5</dd>
  <dt>Specification:</dt>
  <dd style="margin-left: 8">This document.</dd>
</dl>
<h1 id="rfc.section.6.3"><a href="#rfc.section.6.3">6.3.</a> <a href="#iana-errors" id="iana-errors">New HTTP/2 Error Codes</a></h1>
<p id="rfc.section.6.3.p.1">Five new error codes are registered in the &#8220;HTTP/2 Error Code&#8221; registry established in <a href="#RFC7540">[RFC7540]</a>.</p>
<h1 id="rfc.section.6.3.1"><a href="#rfc.section.6.3.1">6.3.1.</a> <a href="#badcertificate" id="badcertificate">BAD_CERTIFICATE</a></h1>
<p/>

<dl>
  <dt>Name:</dt>
  <dd style="margin-left: 8">BAD_CERTIFICATE</dd>
  <dt>Code:</dt>
  <dd style="margin-left: 8">0xERROR-TBD1</dd>
  <dt>Specification:</dt>
  <dd style="margin-left: 8">This document.</dd>
</dl>
<h1 id="rfc.section.6.3.2"><a href="#rfc.section.6.3.2">6.3.2.</a> <a href="#unsupportedcertificate" id="unsupportedcertificate">UNSUPPORTED_CERTIFICATE</a></h1>
<p/>

<dl>
  <dt>Name:</dt>
  <dd style="margin-left: 8">UNSUPPORTED_CERTIFICATE</dd>
  <dt>Code:</dt>
  <dd style="margin-left: 8">0xERROR-TBD2</dd>
  <dt>Specification:</dt>
  <dd style="margin-left: 8">This document.</dd>
</dl>
<h1 id="rfc.section.6.3.3"><a href="#rfc.section.6.3.3">6.3.3.</a> <a href="#certificaterevoked" id="certificaterevoked">CERTIFICATE_REVOKED</a></h1>
<p/>

<dl>
  <dt>Name:</dt>
  <dd style="margin-left: 8">CERTIFICATE_REVOKED</dd>
  <dt>Code:</dt>
  <dd style="margin-left: 8">0xERROR-TBD3</dd>
  <dt>Specification:</dt>
  <dd style="margin-left: 8">This document.</dd>
</dl>
<h1 id="rfc.section.6.3.4"><a href="#rfc.section.6.3.4">6.3.4.</a> <a href="#certificateexpired" id="certificateexpired">CERTIFICATE_EXPIRED</a></h1>
<p/>

<dl>
  <dt>Name:</dt>
  <dd style="margin-left: 8">CERTIFICATE_EXPIRED</dd>
  <dt>Code:</dt>
  <dd style="margin-left: 8">0xERROR-TBD4</dd>
  <dt>Specification:</dt>
  <dd style="margin-left: 8">This document.</dd>
</dl>
<h1 id="rfc.section.6.3.5"><a href="#rfc.section.6.3.5">6.3.5.</a> <a href="#badsignature" id="badsignature">BAD_SIGNATURE</a></h1>
<p/>

<dl>
  <dt>Name:</dt>
  <dd style="margin-left: 8">BAD_SIGNATURE</dd>
  <dt>Code:</dt>
  <dd style="margin-left: 8">0xERROR-TBD5</dd>
  <dt>Specification:</dt>
  <dd style="margin-left: 8">This document.</dd>
</dl>
<h1 id="rfc.section.6.3.6"><a href="#rfc.section.6.3.6">6.3.6.</a> <a href="#certificategeneral" id="certificategeneral">CERTIFICATE_GENERAL</a></h1>
<p/>

<dl>
  <dt>Name:</dt>
  <dd style="margin-left: 8">CERTIFICATE_GENERAL</dd>
  <dt>Code:</dt>
  <dd style="margin-left: 8">0xERROR-TBD6</dd>
  <dt>Specification:</dt>
  <dd style="margin-left: 8">This document.</dd>
</dl>
<h1 id="rfc.section.7"><a href="#rfc.section.7">7.</a> <a href="#ack" id="ack">Acknowledgements</a></h1>
<p id="rfc.section.7.p.1">Eric Rescorla pointed out several failings in an earlier revision.  Andrei Popov contributed to the TLS considerations.</p>
<h1 id="rfc.references"><a href="#rfc.references">8.</a> References</h1>
<h1 id="rfc.references.1"><a href="#rfc.references.1">8.1.</a> Normative References</h1>
<table>
  <tbody>
    <tr>
      <td class="reference">
        <b id="I-D.ietf-tls-tls13">[I-D.ietf-tls-tls13]</b>
      </td>
      <td class="top"><a>Rescorla, E.</a>, "<a href="http://tools.ietf.org/html/draft-ietf-tls-tls13-12">The Transport Layer Security (TLS) Protocol Version 1.3</a>", Internet-Draft draft-ietf-tls-tls13-12, March 2016.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC2119">[RFC2119]</b>
      </td>
      <td class="top"><a>Bradner, S.</a>, "<a href="http://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC2459">[RFC2459]</b>
      </td>
      <td class="top"><a>Housley, R.</a>, <a>Ford, W.</a>, <a>Polk, W.</a> and <a>D. Solo</a>, "<a href="http://tools.ietf.org/html/rfc2459">Internet X.509 Public Key Infrastructure Certificate and CRL Profile</a>", RFC 2459, DOI 10.17487/RFC2459, January 1999.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC5246">[RFC5246]</b>
      </td>
      <td class="top"><a>Dierks, T.</a> and <a>E. Rescorla</a>, "<a href="http://tools.ietf.org/html/rfc5246">The Transport Layer Security (TLS) Protocol Version 1.2</a>", RFC 5246, DOI 10.17487/RFC5246, August 2008.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC5280">[RFC5280]</b>
      </td>
      <td class="top"><a>Cooper, D.</a>, <a>Santesson, S.</a>, <a>Farrell, S.</a>, <a>Boeyen, S.</a>, <a>Housley, R.</a> and <a>W. Polk</a>, "<a href="http://tools.ietf.org/html/rfc5280">Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile</a>", RFC 5280, DOI 10.17487/RFC5280, May 2008.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC5705">[RFC5705]</b>
      </td>
      <td class="top"><a>Rescorla, E.</a>, "<a href="http://tools.ietf.org/html/rfc5705">Keying Material Exporters for Transport Layer Security (TLS)</a>", RFC 5705, DOI 10.17487/RFC5705, March 2010.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC7230">[RFC7230]</b>
      </td>
      <td class="top"><a>Fielding, R.</a> and <a>J. Reschke</a>, "<a href="http://tools.ietf.org/html/rfc7230">Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing</a>", RFC 7230, DOI 10.17487/RFC7230, June 2014.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC7540">[RFC7540]</b>
      </td>
      <td class="top"><a>Belshe, M.</a>, <a>Peon, R.</a> and <a>M. Thomson</a>, "<a href="http://tools.ietf.org/html/rfc7540">Hypertext Transfer Protocol Version 2 (HTTP/2)</a>", RFC 7540, DOI 10.17487/RFC7540, May 2015.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC7627">[RFC7627]</b>
      </td>
      <td class="top"><a>Bhargavan, K.</a>, <a>Delignat-Lavaud, A.</a>, <a>Pironti, A.</a>, <a>Langley, A.</a> and <a>M. Ray</a>, "<a href="http://tools.ietf.org/html/rfc7627">Transport Layer Security (TLS) Session Hash and Extended Master Secret Extension</a>", RFC 7627, DOI 10.17487/RFC7627, September 2015.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="X690">[X690]</b>
      </td>
      <td class="top"><a>ITU-T</a>, "<a href="http://www.itu.int/ITU-T/studygroups/com17/languages/X.690-0207.pdf">Information technology - ASN.1 encoding Rules: Specification of Basic Encoding Rules (BER), Canonical Encoding Rules (CER) and Distinguished Encoding Rules (DER)</a>", ISO ISO/IEC 8825-1:2002, 2002.</td>
    </tr>
  </tbody>
</table>
<h1 id="rfc.references.2"><a href="#rfc.references.2">8.2.</a> Informative References</h1>
<table>
  <tbody>
    <tr>
      <td class="reference">
        <b id="I-D.ietf-httpbis-alt-svc">[I-D.ietf-httpbis-alt-svc]</b>
      </td>
      <td class="top"><a>mnot, m.</a>, <a>McManus, P.</a> and <a>J. Reschke</a>, "<a href="http://tools.ietf.org/html/draft-ietf-httpbis-alt-svc-14">HTTP Alternative Services</a>", Internet-Draft draft-ietf-httpbis-alt-svc-14, March 2016.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="I-D.nottingham-httpbis-origin-frame">[I-D.nottingham-httpbis-origin-frame]</b>
      </td>
      <td class="top"><a>mnot, m.</a> and <a>E. Nygren</a>, "<a href="http://tools.ietf.org/html/draft-nottingham-httpbis-origin-frame-01">The ORIGIN HTTP/2 Frame</a>", Internet-Draft draft-nottingham-httpbis-origin-frame-01, January 2016.</td>
    </tr>
  </tbody>
</table>
<h1 id="rfc.authors">
  <a href="#rfc.authors">Authors' Addresses</a>
</h1>
<div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Mike Bishop</span> 
	  <span class="n hidden">
		<span class="family-name">Bishop</span>
	  </span>
	</span>
	<span class="org vcardline">Microsoft</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:michael.bishop@microsoft.com">michael.bishop@microsoft.com</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Martin Thomson</span> 
	  <span class="n hidden">
		<span class="family-name">Thomson</span>
	  </span>
	</span>
	<span class="org vcardline">Mozilla</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:martin.thomson@gmail.com">martin.thomson@gmail.com</a></span>

  </address>
</div>

</body>
</html>
